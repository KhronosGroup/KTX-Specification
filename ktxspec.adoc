= KTX^™️^ File Format Specification
:author: Mark Callow
:author_org: Edgewise Consulting
:description: Specification for container format for OpenGL^®^ and Vulkan^®^ textures.
:docrev: draft9
:ktxver: 2.0
:revnumber: {ktxver}.{docrev}
:revdate: {docdate}
:version-label: Version
:lang: en
:docinfo1:
:doctype: article
:encoding: utf-8
////
// Choose latexmath. A desire for italicized multi-letter variable
// names and indented blocks, overrides the unreadable equations.
////
:stem: latexmath
// Disabling toc and numbered attributes doesn't work with a2x.
// Use the xsltproc options instead.
:toc!:
// a2x: --xsltproc-opts "--stringparam generate.toc nop"
:numbered:
// a2x: --xsltproc-opts "--stringparam chapter.autolabel 0"
// a2x: --xsltproc-opts "--stringparam section.autolabel 0"
//:max-width: 50em
:data-uri:
:icons: font
:source-highlighter: prettify
:stylesheet: khronos.css
:xrefstyle: full

:url-khr-reg: https://www.khronos.org/registry
:url-khr-vulkan: {url-khr-reg}/vulkan

////
// This part is the Preamble whose 1st 'graph is given [.lead] role
// by default meaning it is rendered in a larger font.  Add [.lead]
// to the other Preamble 'graphs so they match.
////
*Format Version:* 2.0

[.lead]
*Document Revision:* {docrev}

[.lead]
*Editor:* {author} ({author_org})

[.legal]
© 2018 The Khronos Group Inc. All Rights Reserved. See <<License>>.

[abstract]
== Abstract
The KTX file format, version 2 is a format for storing textures
for OpenGL^®^, OpenGL ES^™️^ and Vulkan^®^ applications.  It is
distinguished by the simplicity of the loader required to instantiate
texture objects from the file contents.

It extends the version 1 format with support for easier loading of Vulkan
textures, easier use by non-OpenGL and non-Vulkan applications, storage of
multisample images, streaming and supercompression.

[discrete]
=== Status of this document

WIP. Under review; not ready for implementation.

== Introduction

This document describes the KTX file format version 2.0, hereafter
referred to as _KTX2_^™️^. KTX2 files are used for storing textures for
use with 3D API's such as OpenGL, OpenGL ES and Vulkan.

The canonical version of the specification is available in the
Khronos Registry ({url-khr-reg}). The source files used to generate
the specification are stored in the KTX-Specification Repository
(https://github.com/KhronosGroup/KTX-Specification).  The source
repository has a public issue tracker and allows the submission of
pull requests that improve the specification.

=== Document Conventions

The KTX2 specification is intended for use by both creators and
consumers of KTX2 files forming a contract between these parties.
Specification text may address either party; typically the intended
audience can be inferred from context

==== Normative Terminology

Within this specification, the key words must, required, should,
recommended, may, and optional are to be interpreted as described
in _Key words for use in RFCs to Indicate Requirement Levels_
<<RFC2119>>.  In text addressing creators, their use expresses
requirements that apply to the files produced.  In text addressing
consumers, their use expresses requirements that must be followed
when, e.g, uploading the textures via a 3D API.

==== Admonitions

NOTE: Notes are non-normative and give further background information
such as rationales.

TIP: Tips are non-normative and give helpful suggestions for
implementers.

CAUTION: Cautions are normative, giving restrictions that must be
followed.

== File Structure

.Basic Structure
[source,c]
----
Byte[12] identifier
UInt32 endianness
UInt32 glTypeSize
Uint32 vkFormat
UInt32 pixelWidth
UInt32 pixelHeight
UInt32 pixelDepth
UInt32 numberOfArrayElements
UInt32 numberOfFaces
UInt32 numberOfMipmapLevels
UInt32 supercompressionScheme

// Data Format Descriptor
UInt32 bytesOfDataFormatDescriptor <1>
for each dfDescriptorBlock that fits in bytesOfDataFormatDescriptors
    dfDescriptorBlock descriptorBlock
    blockPadding[3 - ((descriptor_block_size + 3) % 4)]
end

// Key-Value Data
UInt32 bytesOfKeyValueData
for each keyValuePair that fits in bytesOfKeyValueData
    UInt32   keyAndValueByteSize
    Byte     keyAndValue[keyAndValueByteSize]
    Byte     valuePadding[3 - ((keyAndValueByteSize + 3) % 4)]
end
Byte keyValuePadding[0|4]

// Supercompression Global Data
UInt64 bytesOfSupercompressionGlobalData
Byte supercompressionGlobalData[bytesOfSupercompressionsGlobalData]
Byte sgdPadding[7 - ((bytesOfSupercompressionGlobalData + 7) % 8)]]

UInt64 bytesOfImages
UInt64 bytesOfUncompressedImages

// Level Index
for each mipmap level in numberOfMipmapLevels <2>
    UInt64 levelOffset
end

// Mipmap Level Array
for each mipmap_level in numberOfMipmapLevels <2>
    Uint64 bytesOfLevelImages
    Uint64 bytesOfUncompressedLevelImages
    Byte levelImages[bytesOfLevelImages] <3>
    Byte mipPadding[0-7]
end
----
<1> These 5 lines are a Data Format Descriptor. See <<_data_format_descriptor>>.
    The data format descriptor is required.
<2> Replace with 1 if this field is 0
<3> See <<levelImages>> below.

After inflation from supercompression or when `supercompressionScheme ==
0`, `levelImages` looks like this:

[[levelImages,levelImages]]
.levelImages Structure
[source, c]
----
for each array_element in numberOfArrayElements <1>
   for each face in numberOfFaces
       for each z_slice_of_blocks in num_blocks_z <2>
           for each row_of_blocks in num_blocks_y <2>
               for each block in num_blocks_x <2>
                   Byte data[format-specific-number-of-bytes] <3>
               end
           end
       end
   end
end
----
<1> Replace with 1 if this field is 0.
<2> See <<levelImages_defs,the definitions>> below.
<3> Rows of uncompressed texture images must be tightly packed,
    equivalent to a `GL_UNPACK_ALIGNMENT` of 1.

[[levelImage_defs]]In the `levelImages` loops above,

[stem]
// num_blocks_z = max(1, ceil(pixelDepth / block_depth))
+++++
num\_blocks\_z = \max\left(1, \left\lceil{\frac{pixelDepth}{block\_depth}}\right\rceil\right)
+++++

[stem]
// num_blocks_y = max(1, ceil(pixelHeight / block_height))
+++++
num\_blocks\_y = \max\left(1, \left\lceil{\frac{pixelHeight}{block\_height}}\right\rceil\right)
+++++

[stem]
// num_blocks_x = ceil(pixelWidth / block_width)
+++++
num\_blocks\_x = \left\lceil{\frac{pixelWidth}{block\_width}}\right\rceil
+++++

where _block_depth_, _block_height_, and _block_width_ are `1` for
uncompressed formats and the block size in that dimension for block
compressed formats as given in the format's section of the Khronos
Data Format specification <<KDF12>>.

A _block_ is a single pixel for uncompressed formats and
stem:[block\_width \times block\_height \times block\_depth]
pixels for block compressed formats.

== Field Descriptions

=== identifier
The file identifier is a unique set of bytes that will differentiate the file 
from other types of files. It consists of 12 bytes, as follows:
[source,c]
----
Byte[12] FileIdentifier = {
  0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x32, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
}
----
This can also be expressed using C-style character definitions as:
[source,c]
----
Byte[12] FileIdentifier = {
  '«', 'K', 'T', 'X', ' ', '2', '2', '»', '\r', '\n', '\x1A', '\n'
}
----
The rationale behind the choice of values in the identifier is based
on the rationale for the identifier in the PNG specification. This
identifier both identifies the file as a KTX file and provides for
immediate detection of common file-transfer problems.

  * Byte [0] is chosen as a non-ASCII value to reduce the probability that a 
    text file may be misrecognized as a KTX file.
  * Byte [0] also catches bad file transfers that clear bit 7.
  * Bytes [1..6] identify the format, and are the ascii values for the string 
    "KTX 22".
  * Byte [7] is for aesthetic balance with byte 1 (they are a matching pair 
    of double-angle quotation marks).
  * Bytes [8..9] form a CR-LF sequence which catches bad file transfers that 
    alter newline sequences.
  * Byte [10] is a control-Z character, which stops file display under MS-DOS, 
    and further reduces the chance that a text file will be falsely recognised.
  * Byte [11] is a final line feed, which checks for the inverse of the CR-LF 
    translation problem.

=== endianness
`endianness` contains the number 0x04030201 written as a 32 bit
integer. If the file is little endian then this is represented as
the bytes 0x01 0x02 0x03 0x04. If the file is big endian then this
is represented as the bytes 0x04 0x03 0x02 0x01. When reading
`endianness` as a 32 bit integer produces the value 0x04030201 then
the endianness of the file matches the endianness of the program
that is reading the file and no conversion is necessary.  When
reading `endianness` as a 32 bit integer produces the value 0x01020304
then the endianness of the file is opposite the endianness of the
program that is reading the file. In that case the program reading
the file must endian convert all header UInt32s and UInt64s and,
when `<<glTypeSize>> != 1`, all `data` to the endianness of the program
(i.e. a little endian program must convert from big endian, and a
big endian program must convert from little endian).

=== glTypeSize
`glTypeSize` specifies the data type size that should be used when
endianness conversion is required for the texture data stored in
the file. If glType is not 0, this should be the size in bytes
corresponding to glType. For texture data which does not depend on
platform endianness, including block compressed texture data,
`glTypeSize` must equal 1.

=== vkFormat
`vkFormat` specifies the image format using Vulkan `VkFormat` enum
values. It can be any value defined in core Vulkan 1.1 <<VULKAN11>>,
future core versions or by a registered Vulkan extension. Values
defined by core Vulkan 1.1 are given in
{url-khr-vulkan}/specs/1.1/html/vkspec.html#features-formats-definition[section
30.3.1 _Format Definition_] of <<VULKAN11>>.  The list of registered
extensions is provided in the {url-khr-vulkan}vulkan/#repo-docs[Khronos
Vulkan Registry]. A complete list of values defined by both core
Vulkan 1.1 and extensions can be found in
{url-khr-vulkan}/specs/1.1-extensions/html/vkspec.html#features-formats-definition[section
35.4.1 _Format Definition_] of <<VULKAN11EXT>>.

NOTE: The section number given for <<VULKAN11EXT>> is as of this
writing (Vulkan 1.1.96). It is subject to change as future extensions
are added to the document but the link should remain valid as it is to
an internal anchor.

`vkFormat` can be `VK_FORMAT_UNDEFINED` (0) if the format of the data
is a not a recognized Vulkan format. The data layout is always given by
the Data Format Descriptor.

Values listed in <<prohibitedFormats>> must not be used nor any
`\*_SCALED_*` formats added in future.  The table in <<formatMapping>>
gives the mapping for all `VkFormat` enum values in Vulkan 1.1 core
and the extensions known at the time of writing, to the equivalent
OpenGL format (internal format, format and type values), DXGI_FORMAT
and MTLPixelFormat. Applications must use these mappings. If
<<formatMapping>> does not have an entry for the value of `vkFormat`,
and a mapping for one or more of the other APIs exists the KTX2
writer must provide that mapping using one or more of the metadata
items described in <<formatMappingMetadata>>. This includes the
case of `VK_FORMAT_UNDEFINED`.

There are not yet Vulkan extensions for the ASTC HDR and 3D formats
described in _OES_texture_compression_ASTC_ <<OES_ASTC>>. ASTC
formats are indicated in the DFD by setting `color_model` to
`KHR_DF_MODEL_ASTC (= 162)`. HDR data is indicated by setting the
`channel_id` `KHR_DF_SAMPLE_DATATYPE_FLOAT` bit to 1. The block
size is given by the values of `texture_block_dimension_0` and
`texture_block_dimension_1` and an ASTC 3D texture is indicated by
`texel_block_dimension_2` > 0. Tools handling ASTC and OpenGL loaders
must be be able to recognize these formats from the DFD.

[TIP]
====
Before loading any image, Vulkan loaders should confirm via
`vkGetPhysicalDeviceFormatProperties` that the Vulkan physical
device (`VkDevice`) supports the the intended use of the format.

Vulkan applications using a core Vulkan format whose name has the
`_BLOCK` suffix must ensure they enable the corresponding
`textureCompression*` physical device feature at `VkDevice` creation
time. Those using formats defined by extensions must ensure they
enable the defining extension at `VkDevice` creation time.

Vulkan applications handling textures whose formats are not known at
`VkDevice` creation time are recommended to enable all available texture
compression features and format defining extensions when creating a
device.
====

[width=50%,align=center,cols="<,^",options=header]
[[prohibitedFormats]]
.Prohibited Formats
|===
| Format Name                          | Value
| VK_FORMAT_A8B8G8R8_UNORM_PACK32      | 51
| VK_FORMAT_A8B8G8R8_SNORM_PACK32      | 52
| VK_FORMAT_A8B8G8R8_UINT_PACK32       | 55
| VK_FORMAT_A8B8G8R8_SINT_PACK32       | 56
| VK_FORMAT_A8B8G8R8_SRGB_PACK32       | 57
| VK_FORMAT_R8_USCALED                 | 11
| VK_FORMAT_R8_SSCALED                 | 12
| VK_FORMAT_R8G8_USCALED               | 18
| VK_FORMAT_R8G8_SSCALED               | 19
| VK_FORMAT_R8G8B8_USCALED             | 25
| VK_FORMAT_R8G8B8_SSCALED             | 26
| VK_FORMAT_B8G8R8_USCALED             | 32
| VK_FORMAT_B8G8R8_SSCALED             | 33
| VK_FORMAT_R8G8B8A8_USCALED           | 39
| VK_FORMAT_R8G8B8A8_SSCALED           | 40
| VK_FORMAT_B8G8R8A8_USCALED           | 46
| VK_FORMAT_B8G8R8A8_SSCALED           | 47
| VK_FORMAT_A8B8G8R8_USCALED_PACK32    | 53
| VK_FORMAT_A8B8G8R8_SSCALED_PACK32    | 54
| VK_FORMAT_A2R10G10B10_USCALED_PACK32 | 60
| VK_FORMAT_A2R10G10B10_SSCALED_PACK32 | 61
| VK_FORMAT_A2B10G10R10_USCALED_PACK32 | 66
| VK_FORMAT_A2B10G10R10_SSCALED_PACK32 | 67
| VK_FORMAT_R16_USCALED                | 72
| VK_FORMAT_R16_SSCALED                | 73
| VK_FORMAT_R16G16_USCALED             | 79
| VK_FORMAT_R16G16_SSCALED             | 80
| VK_FORMAT_R16G16B16_USCALED          | 86
| VK_FORMAT_R16G16B16_SSCALED          | 87
| VK_FORMAT_R16G16B16A16_USCALED       | 93
| VK_FORMAT_R16G16B16A16_SSCALED       | 94
|===

[NOTE]
.Rationale
====
The A8B8G8R8*PACK32 formats are prohibited because the end result
is the same regardless of whether the data is treated as packed
into 32-bits or as the equivalent R8G8B8A8 format, i.e. as an array
of 4 bytes, and a Data Format Descriptor cannot distinguish between
these cases.

The \*SCALED* formats are prohibited because they are intended for
vertex data, very few, if any, implementations support using them
for texturing and a Data Format Descriptor cannot distinguish
these from `int` values having the same bit pattern.
====

[CAUTION]
.Legacy Formats
====
The legacy OpenGL & OpenGL ES formats specified by the following
extensions, do not have equivalent Vulkan formats and are not
supported.

- OES_compressed_paletted_texture
- AMD_compressed_3DC_texture
- AMD_compressed_ATC_texture
- 3DFX_texture_compression_FXT1
- EXT_texture_compression_latc

Only a few of these formats can be described without an extended
Data Format Descriptor so `VK_FORMAT_UNDEFINED` must not be used
as a workaround.

This is felt to be an acceptable trade-off for simplifying this
specification as the formats are not in wide use and applications
needing them can use KTX version 1.
====

=== [[dimensions]]pixelWidth, pixelHeight, pixelDepth
The size of the texture image for level 0, in pixels. No rounding
to block sizes should be applied for block compressed textures.

For 1D textures `pixelHeight` and `pixelDepth` must be 0. For 2D and
cube textures `pixelDepth` must be 0.

`pixelWidth` cannot be 0.

=== numberOfArrayElements
`numberOfArrayElements` specifies the number of array elements. If
the texture is not an array texture, `numberOfArrayElements` must
equal 0.

Although current graphics APIs do not support 3D array textures, KTX 
files can be used to store them.

Refer to the <<_texture_type>> section for more details about valid values. 

=== numberOfFaces
`numberOfFaces` specifies the number of cubemap faces. For cubemaps
and cubemap arrays this must be 6. For non cubemaps this must be 1.
Cube map faces are stored in the order: +X, -X, +Y, -Y, +Z, -Z.

Applications wanting to store incomplete cubemaps should flatten faces
into a 2D array and use the metadata described in <<KTXcubemapIncomplete>>
to signal which faces are present.

=== numberOfMipmapLevels
`numberOfMipmapLevels` specifies the number of levels in Mipmap
Level Array and, by extension, the number of indices in the Level
Index array. Mipmap level data is ordered from the smallest image
size, _level~p~_ to the largest image size, _level~base~_.
`numberOfMipmapLevels` must not be greater than _level~max~_, the
_log~2~_ of the maximum of `pixelWidth`, `pixelHeight` and `pixelDepth`.

A KTX file does not need to contain a complete mipmap pyramid. If
`numberOfMipmapLevels` is not equal to _level~base~_, it indicates
the file contains levels from some _level~p~_ to _level~base~_
where stem:[p = numberOfMipmapLevels - 1].

stem:[numberOfMipmapLevels = 1] means that a file contains only the
first level and the texture isn't meant to have other levels. E.g.,
this could be a LUT rather than a natural image.

stem:[numberOfMipmapLevels = 0] is allowed, except for block-compressed
formats, and means that a file contains only the first level and
consumers, particularly loaders, should generate other levels if
needed.

=== supercompressionScheme
`supercompressionScheme` indicates if an optional supercompression
scheme has been applied to the data in `<<levelImages>>`.  It must
be one of the values from <<supercompressionSchemes>>. A value of `0`
indicates no supercompression.

[width=100%,align=center,cols="^15,<25,<30,<30",options=header]
[[supercompressionSchemes]]
.Supercompression Schemes
|===
| Scheme Id   | Scheme Name | Level Data Format | Global Data Format
| 0           | None        |   n/a       | n/a
| 1           | Crunch CRN  |   T.B.C     | T.B.C
| 2           | ZLIB        |  <<ZLIB>>   | n/a
| 3           | Zstandard   |  <<ZSTD>>   | n/a
| 4･･･2^32^-1 | Reserved^1^ |             |
|===

1. A registry will be established to issue values in the reserved range
   for vendor compression schemes thus avoiding conflicts.

The supercompression scheme is applied independently to each mip
level to permit streaming and random access to the levels. The
format of the data in `<<levelImages>>` for a scheme is specified
in the reference given in the _Level Data Format_ column of
<<supercompressionSchemes>>.

Schemes that require data global to all levels can store it in
`<<supercompressionGlobalData>>`. Currently only Crunch CRN uses
global data. Thje format of the global data for a scheme is specified
in the reference given in the _Global Data Format_ column
of <<supercompressionSchemes>>.

When a supercompression scheme is used, the image data must be
inflated from the scheme prior to GPU sampling.

[TIP]
====
LZW-style lossless supercompression, e.g, schemes 2 and 3, is
generally ineffective on the block-compressed data of GPU
texture formats. It is best reserved for use with uncompressed
texture formats or with block-compressed data that has been specially
optimized for LZW-style supercompression, such as by Crunch's _Rate
Distortion Optimization_ mode <<RDO>>.

Crunch CRN is specially designed for supercompression of some
block-compressed texture formats.
====

==== Scheme Notes (Normative)
===== Crunch CRN
* A file that specifies Crunch CRN with base formats other than ETC,
  ETC2 and BC[1-3] (S3TC_DXT[1-5]) must be considered invalid.

===== ZLIB

* With Deflate <<DEFLATE>> compression scheme.

===== Zstandard
* Only _Zstandard_ frames are required. Inflators may skip _Skippable_
  frames.

* Checksums are optional. If a checksum is present, inflators should
  verify it.

=== Data Format Descriptor
The next 3 items combined form a _Data Format Descriptor_
(dfDescriptor) describing the layout of the texel blocks in `data`.
The full specification for this can be found in the _Khronos Data
Format Specification_ version 1.2 <<KDF12>>.

If the dfDescriptor describes an sRGB transfer function then `vkFormat`
must be one of the _SRGB_ formats.

The dfDescriptor is partially expanded here in order to provide
sufficient information for a KTX2 file to be parsed without having to
refer to <<KDF12>>. If consists of one or more _Descriptor Blocks_
(dfDescriptorBlock).

If the 

The Data Format Descriptor describes the texel blocks as they are when
`supercompressionScheme == 0` or after reflation when
`supercompressionScheme != 0`.

[NOTE]
.Rationale
====
`dfFormatDescriptor` is useful in the following cases:

* precise color management using the descriptor's color space
  information,
* storing multi-sample images. Neither OpenGL nor Vulkan define formats
  or an API for loading these. Applications can use the descriptor and
  a custom shader to load these.
* easier use of the images by non-OpenGL and non-Vulkan applications.
  There will be no need for large tables to interpret format enums.
* easier calculation of the offsets of each level, face and layer within
  the data. Again there will be no need for large tables.
====

==== bytesOfDataFormatDescriptor
Called `total_size` in <<KFD12>>, `bytesOfDataFormatDescriptor`
indicates the total number of bytes in the dfDescriptor including
all dfDescriptorBlocks and all `<<blockPadding>>` fields.

==== descriptorBlock
A `Descriptor Block` as defined in <<KDF12>>, the high-order 16
bits of its first UInt32 give the descriptor type and the high-order
16 bits of the second UInt32 give the `descriptor_block_size`.

==== blockPadding
`blockPadding` contains between 0 and 3 bytes of value `0x00` to ensure
that the byte following the last byte in `blockPadding` is at a file offset
that is a multiple of 4. This ensures that every `descriptorBlock` field and
the following `bytesOfKeyValueData` field are 4-byte aligned. This padding
is included in `<<bytesOfDataFormatDescriptor>>` but not in the individual
`descriptor_block_sizes`.

The _Khronos Basic Data Format Descriptor Block_ which will be the type
used in the vast majority of cases has a length guaranteed to be a
multiple of 4 so typically there will be 0 bytes of padding.

=== Key-Value Data
==== bytesOfKeyValueData
An arbitrary number of key/value pairs may follow the header. This
can be used to encode any arbitrary data. The `bytesOfKeyValueData`
field indicates the total number of bytes of key/value data including
all `keyAndValueByteSize` fields, all `keyAndValue` fields and all
`<<valuePadding>>` fields but not the `<<keyValuePadding>>` field.
The file offset of the `<<bytesOfImages>>` field is located at the
file offset of the `bytesOfKeyValueData` field plus 4 plus the value
of the `bytesOfKeyValueData` field rounded to the next 8-byte
boundary.

KTX2 editors must preserve any key/value data they do not understand
or which is not modified by the user.

==== keyAndValueByteSize
`keyAndValueByteSize` is the number of bytes of combined key and value
data in one key/value pair following the header. This includes the
size of the key, the NUL byte terminating the key, and all the bytes
of data in the value. If the value is a UTF-8 string it should be
NUL terminated and the `keyAndValueByteSize` should include tlhe NUL
character (but code that reads KTX files must not assume that value
fields are NUL terminated). `keyAndValueByteSize` does not include
the bytes in `<<valuePadding>>`.

==== keyAndValue
`keyAndValue` contains 2 separate sections. First it contains a key
encoded in UTF-8 without a byte order mark (BOM). The key must be 
terminated by a NUL character (a single 0x00 byte). Keys that begin 
with the 3 ASCII characters 'KTX' or 'ktx' are reserved and must not
be used except as described by this spec (this version of the KTX spec
defines two keys). Immediately following the NUL character that terminates
the key is the Value data.

The Value data may consist of any arbitrary data bytes. Any byte
value is allowed. It is encouraged that the value be a NUL terminated
UTF-8 string without a BOM, but this is not required. If the Value data
is binary, it is a sequence of bytes rather than of words. It is up to
the vendor defining the key to specify how those bytes are to be
interpreted (including the endianness of any encoded numbers). If
the Value data is a string of bytes then the NUL termination should
be included in the `<<keyAndValueByteSize>>` byte count (but programs
that read KTX files must not rely on this).

==== valuePadding
`valuePadding` contains between 0 and 3 bytes of value `0x00` to ensure that
the byte following the last byte in `valuePadding` is at a file offset that
is a multiple of 4. This ensures that every `<<keyAndValueByteSize>>`
field is 4-byte aligned. This padding is included in the
`<<bytesOfKeyValueData>>` field but not the individual
`<<keyAndValueByteSize>>` fields.

==== keyValuePadding
`keyValuePadding` contains either 0 or 4 bytes of value `0x00` to ensure that
the following `<<bytesOfSupercompressionGlobalData>>` field is at a file
offset that is a multiple of 8.

=== Supercompression Global Data
==== bytesOfSupercompressionGlobalData
`bytesOfSupercompressionGlobalData` indicates the number of bytes
of `<<supercompressionGlobalData>>`. It does not include `sgdPadding`.
For most schemes the value is 0.

==== supercompressionGlobalData
`supercompressionGlobalData` is an array of data used by certain 
supercompression schemes that must be available before any mip level
can be expanded.

==== sgdPadding
`sgdPadding` contains between 0 and 7 bytes of value `0x00` to ensure
that `<<bytesOfImages>>` is at a file offset that is a multiple of 8.

=== bytesOfImages
The total size of the image data. That is the sum of the
`<<bytesOfLevelImages>>` within the Mipmap level array.

=== bytesOfUncompressedImages
The size of the image data after expansion from supercompression.
When `supercompressionScheme == 0`, `<<bytesOfImages>>` must have the same
value as this.

=== Level Index
This array provides the offset within the <<_mipmap_level_array>>
for each mip level. The offsets are ordered starting with that of
_level~base~_ (the level with the largest size images) at index 0.
This index provides random access to supercompressed data. It is
not necessary for non-supercompressed data, as the sizes and offsets
can be calculated, but for consistency and reducing the possibilities
for error it must always be included in a KTX file.

==== levelOffset
`levelOffset` gives the offset of a mipmap level from the start of the
<<_mipmap_level_array>>.

=== Mipmap Level Array

Mipmap levels in the array are ordered from the level with the
smallest size images, _level~p~_ to that with the largest size
images, _level~base~_.

[NOTE]
.Rationale
====
When streaming a KTX file, sending smaller mip levels first can be
used together with, e.g., the `GL_TEXTURE_MAX_LEVEL` and
`GL_TEXTURE_BASE_LEVEL` texture parameters or appropriate region setting
in a `VkCmdCopyBufferToImage`, to display a low resolution image quickly
without waiting for the entire texture data.
====

==== bytesOfLevelImages
The total size of the data for a supercompressed mipmap level.

`bytesOfLevelImages` is the number of bytes of pixel data in the
current LOD level. This includes all z slices, all faces, all rows
(or rows of blocks) and all pixels (or blocks) in each row for the
mipmap level.

If the sum of `bytesOfLevelImages` within the array is not equal
to `<<bytesOfImages>>`, loaders should consider the file invalid and
not load it.

==== bytesOfUncompressedLevelImages
The size of the data for a mipmap level after reflation from
supercompression.  When `supercompressionScheme == 0`,
`<<bytesOfLevelImages>>` must have the same value as this.

`bytesOfUncompressedLevelImages` is the number of bytes of pixel
data in the current LOD level after reflation from supercompression.
This includes all z slices, all faces, all rows (or rows of blocks)
and all pixels (or blocks) in each row for the mipmap level. It
does not include any bytes in `<<mipPadding>>`.

The value of `bytesOfUncompressedLevelImages` must satisfy the
following condition:
[listing]
----
bytesOfUncompressedLevelImages % (numberOfFaces * max(1, numberOfArrayElements)) == 0
----

If the sum of `bytesOfUncompressedLevelImages` within the array is
not equal to `<<bytesOfUncompressedImages>>`, loaders should consider
the file invalid and not load it.

[TIP]
====
In versions of OpenGL < 4.5 and in OpenGL ES, faces of non-array
cubemap textures (any texture where `numberOfFaces` is 6 and
`numberOfArrayElements` is 0) must be uploaded individually. Loaders
wishing to minimize the size of their intermediate buffers may want
to read the faces individually rather then as a block of size
`bytesOfUncompressedLevelImages`.
====

==== levelImages
`levelImages` is an array of Bytes holding all the image data for a
level.

When `<<supercompressionScheme>> != 0` these bytes are formatted as specified
in the scheme documentation.

=== mipPadding
`mipPadding` is between 0 and 7 bytes of value `0x00` to make sure that all
`<<bytesOfLevelImages>>` fields are at a file offset that is a multiple of 8.

== General comments
Rows of uncompressed pixel data are tightly packed. Each row in
memory immediately follows the end of the preceding row. I.e the
data must be packed according to the rules described in section
8.4.4.1 _Unpacking_ of the OpenGL 4.6 specification <<OPENGL46>>
with `GL_UNPACK_ROW_LENGTH` = 0 and `GL_UNPACK_ALIGNMENT` = 1.

=== Texture Type
The type of texture can be determined from the following table. Any 
other combination of parameters makes the KTX file invalid.

[options="header"]
|====
|Type         |<<dimensions,pixelWidth>>|<<dimensions,pixelHeight>>|<<dimensions,pixelDepth>>|<<numberOfArrayElements>>|<<numberOfFaces>>
|1D           |> 0       |0          |0         |0                    |1
|2D           |> 0       |> 0        |0         |0                    |1
|3D           |> 0       |> 0        |> 0       |0                    |1
|Cubemap      |> 0       |> 0        |0         |0                    |6
|1D Array     |> 0       |0          |0         |> 0                  |1
|2D Array     |> 0       |> 0        |0         |> 0                  |1
|3D Array     |> 0       |> 0        |> 0       |> 0                  |1
|Cubemap Array|> 0       |> 0        |0         |> 0                  |6
|====

== Predefined Key-Value Pairs

=== KTXcubemapIncomplete
A KTX file can be used to store an incomplete cubemap or an array of 
incomplete cubemaps. In such a case, `numberOfFaces` must be `1` and 
`numberOfArrayElements` must be equal to the number of faces present
(in case of a single cubemap) or to the number of faces present times 
the number of cubemaps (in case of a cubemap array). The faces that are
present must be indicated using the metadata key

-   `KTXcubemapIncomplete`

The value is a one-byte bitfield defined as:

[listing]
-----
00xxxxx1 - +X is present 
00xxxx1x - -X is present
00xxx1xx - +Y is present
00xx1xxx - -Y is present
00x1xxxx - +Z is present
001xxxxx - -Z is present
-----

Any value, not matching the mask above is invalid.

At least one face must be present (i.e., value cannot be `0`).

Within the <<levelImages>> structure, faces must be written in the 
same order as with complete cubemaps: +X, -X, +Y, -Y, +Z, -Z.

When a texture is a cubemap array, missing/present faces must be
the same for each element.

=== KTXorientation
Texture data in a KTX file are arranged so that the first pixel in
the data stream for each face and/or array element is closest to
the origin of the texture coordinate system. In OpenGL that origin
is conventionally described as being at the lower left, but this
convention is not shared by all image file formats and content
creation tools, so there is abundant room for confusion.

The desired texture axis orientation is often predetermined by,
e.g. a content creation tool's or existing application's use of the
image. Therefore it is strongly recommended that tools for generating
and manipulating KTX files clearly describe their behaviour, and
provide an option to specify the texture axis origin and orientation
relative to the logical orientation of the source image. At minimum
they should provide a choice between top-left and bottom-left as
origin for 2D source images, with the positive S axis pointing
right. Where possible, the preferred default is to use the logical
upper-left corner of the image as the texture origin. Note that
this is contrary to the standard interpretation of GL texture
coordinates. However, most other APIs and the majority of texture
compression tools use this convention.

When writing the logical orientation to the KTX file's metadata,
image manipulation tools and viewers must use the key

-   `KTXorientation`

Note that this metadata affects only the logical interpretation of
the data and has no effect on the mapping from pixels in the file
byte stream to texture coordinates.

The value is a NUL-terminated string formatted depending on the texture type.

[options="header"]
|====
|Type|Format (<<REGEXP>>)
|1D  |`/^[rl]$/`
|2D  |`/^[rl][du]$/`
|3D  |`/^[rl][du][oi]$/`
|====

where

- `r` indicates S values increasing to the right
- `l` indicates S values increasing to the left
- `d` indicates T values increasing downwards
- `u` indicates T values increasing upwards
- `o` indicates R values increasing out from the screen (moving towards viewer)
- `i` indicates R values increasing in towards the screen (moving away from viewer)
 
When a texture is an array, all its elements have the same orientation.

Values not matching the table above are invalid.

It is recommended that viewing and editing tools support at least the following values:

- `rd`
- `ru`
- `rdi`
- `ruo`

Although other orientations can be represented, it is recommended
that tools that create KTX files use only the values listed above
as other values may not be widely supported by other tools.

[#formatMappingMetadata]
=== Format Mapping

When <<formatMapping>> does not have an entry for the value of
`vkFormat`, which will happen for newly addded Vulkan formats, the
KTX writer must provide any known mapping via the following key-value
pairs.

Note that the length of these keys, including the terminating `NUL`,
is a multiple of 4 bytes so the values will be 4-byte aligned.

==== KTXglFormat

For OpenGL {,ES} the mapping is specified with the key

- `KTXglFormat`

The value is 12 bytes representing 3 Uint32 values:

[source,c]
----
UInt32 glInternalformat
UInt32 glFormat
UInt32 glType
----

==== KTXdxgiFormat__

For Direct3D the mapping is specified with the key

- `KTXdxgiFormat__`

The value is a UInt32 (4 bytes) giving the format enum value.

==== KTXmetalPixelFormat

For Metal, the mapping is specified with the key

- `KTXmetalPixelFormat`

The value is a UInt32 (4 bytes) giving the format enum value.

=== KTXswizzle

////
[NOTE]
.Differences between OpenGL and Vulkan Swizzle
====
* Vulkan uses an enum, VkComponentSwizzle, with values from 0 (IDENTITY)
  to 6 (SWIZZLE_A). OpenGL uses the values of the existing constants
  GL_RED (0x1903), GL_GREEN (0x1904), GL_BLUE (0x1905), GL_ALPHA (0x1906),
  GL_ZERO (0) and GL_ONE (1).

* OpenGL does not have an identity swizzle.

* Vulkan has a struct VkComponentMapping while OpenGL uses an array of
  component swizzle values.
====
////

Desired component mapping for a texture can be indicated with the key

-   `KTXswizzle`

The value is a four-byte NUL-terminated string formatted as (<<REGEXP>>):

-   `/^[rgba01]{4}$/`

where each symbol represents source component (or fixed value) that 
is used for red, green, blue, and alpha values, thus `rgba` being 
a default swizzling state.

For example, `rg01` means:

- the red and green channels are sampled from the red and green texture 
  components respectively;
- the blue channel is set to zero, ignoring texture data;
- the alpha channel is set to one (fully saturated), ignoring texture data.

When a channel is not present in the texture, a value of `0` must be 
used for colors (red, green, and blue) and a value of `1` (fully 
saturated) must be used for alpha.

==== Common Mappings

Use the following formats and swizzles to map alpha-only, luminance and
luminance-alpha formats.

Alpha8:: 
`vkFormat`: `VK_FORMAT_R8_UNORM` (9)
 +
`KTXswizzle`: 000r

Luminance8::
`vkFormat`: `VK_FORMAT_R8_UNORM` (9)
 +
`KTXswizzle`: rrr1

Luminance8Alpha8::
`vkFormat`: `VK_FORMAT_R8G8_UNORM` (16)
 +
`KTXswizzle`: rrrg

Loaders may opt to detect these cases and use API-provided enums
when available, e.g. for the first case  `GL_ALPHA8` (when using
compatibility profile), `MTLPixelFormatA8Unorm` or `DXGI_FORMAT_A8_UNORM`.

=== KTXwriter
KTX file writers must identify themselves by including a value with
the key

-   `KTXwriter`

The value can be any UTF-8 string that will uniquely identify the tool
writing the file, for example:

-   `AcmeCo TexTool v1.0`

Only the most recent writer should be identified.  Editing tools
must overwrite this value when rewriting a file originally written
by a different tool.

== An example KTX file:

TBC

== IANA Mime-Type Registration Information

[.legal]
_Permission is expressly granted to IANA to copy this section as
necessary for managing the MIME types registry._

TBC

== Issues
[qanda]
How to refer to the DF descriptor block?::
  _Discussion:_ There is no such data type as `dfDesriptorBlock` but
  using primitive types would effectively mean repeating the
  definition of a descriptor block here which we do not want to do.
+
_Resolved:_ Show that `dfDescriptorBlock` is used as a shorthand for
<<KDF12>>'s _Descriptor block_.

How to handle endianness of the DF descriptor block?::
  _Discussion_: The DF spec says data structures are assumed to be
  little-endian for purposes of data transfer. This is incompatible
  with the net which is big-endian and incompatible with `endianness`.
  What should we do?
+
_Unresolved._

Can we guarantee the DF descriptor blocks are always a multiple of 4 bytes?::
  _Discussion_ The _Khronos Basic Data Format Descriptor Block_ is
  a multiple of 4 bytes (24 + 16 x number of samples). Is there
  anything to require that extensions' block sizes be a multiple of
  4 bytes? Need to maintain alignment.
+
_Resolved:_ The Data Format Specification will be updated to recommend
but not require padding. This spec. will require padding.

Should KTX2 support level sizes > 4GB?::
  _Discussion:_ Users have reported having base levels > 4GB for 3D
  textures.  For this the `imageSize` field needs to be 64-bits. Loaders
  on 32-bit systems will have to ensure correct handling of this and
  check that `imageSize` \<= 4GB, before loading.
+
_Resolved:_ Be future proof and make all image-size related fields 64
bits.

Should KTX2 provide a way to distinguish between rectangle and regular 2D textures?::
  _Discussion:_ The difference is that unnormalized texel coordinates
  are used for sampling via a special sampler type in GLSL and, in the
  case of OpenGL {,ES}, the special TEXTURE_RECTANGLE target is used. If
  needed this could be supported by a metadata item instructing to use
  unnormalized texel coordinates.
+
_Unresolved:_

Should KTX2 provide a way to distinguish between 1D textures and buffer textures?::
  _Discussion:_ The difference is how you use the data in OpenGL.
  With buffer textures the image data is stored in a buffer object.
  Note that a TextureView can be used to give a different view of the
  data so supporting buffer textures probably requires metadata to
  indicate a preferred view as well as metadata to indicate
  the data should be loaded in a buffer.
+
_Unresolved:_

Should KTX2 drop the `gl*` fields?::
  _Discussion:_ Narrowing down and enforcing the valid combinations
  of `glFormat`, `glInternalFormat` and `glType` is fraught with
  issues. The spec. could be simplified by dropping them and having
  only `vkFormat`.  The spec can include a table showing a standard
  mapping from the `vkFormat` value to a `glInternalFormat`,
  `glFormat` and `glType` combination.
+
_Resolved:_ Drop the `gl*` fields. OpenGL and OpenGL ES loaders
can include code to do the mapping based on table which will be
added to the spec. Such code is estimated to be about 6 kbytes.

Use alphanumeric characters or binary values for component swizzles?::
  _Discussion:_ Values in the swizzle metadata could be either a
  character from the set [01rgba] or numeric values corresponding to the
  VkComponentSwizzle enum values from 0 to 6. In the latter case values
  could be expressed in binary or as numeric characters. The
  GL token values have been eliminated from this choice because they
  are not user friendly.
+
_Resolved:_ Use alphanumeric characters from the set [01rgba].

Is anything needed to support sparse textures?::
  _Discussion:_ Sparse textures are provided by the
  `GL_ARB_sparse_textures` extension and are a standard feature of
  Vulkan.  Are any additional KTX features needed to support them?
+
_Unresolved:_

Should KTX2 support metadata for effective use of Vulkan SCALED formats?::
  _Discussion:_ Vulkan SCALED formats convert int (or uint) values
  to unnormalized floating point values, equivalent to specifying a
  value of `GL_FALSE` for the `normalized` parameter to
  `glVertexAttribFormat`. Generally when using such data, associated
  scale and bias values are folded into the transformation matrix.
  Should KTX2 specify standard metadata for these?
+
_Resolved:_ No. These formats will not be supported. They are
primarily for vertex data and several Vulkan vendors have said they
can't support them as texture formats. Also a DFD cannot distinguish
these from `int` values having the same bit pattern.

Should the supercompression scheme be applied per-mip-level?::
  _Discussion:_ Should each mip level be supercompressed independently
  or should the scheme, zlib, zstd, etc., be applied to all levels
  as a unit? The latter may result in slightly smaller size though
  that is unclear. However it would also mean levels could not be
  streamed or randomly accessed.
+
_Resolved:_ Yes. The benefits of streaming and random access outweigh
what is expected to be a small increase in size.

Should we remove row padding from uncompressed image data?::
  _Discussion:_ Row padding was added to KTX so that data would have the
  default GL_UNPACK_ALIGNMENT of 4, which was chosen to help speed up DMA
  of rows by the GPU. Modern architectures are apparently not sensitive
  to this as evidenced by Vulkan deliberately omitting any equivalent of
  GL_UNPACK_ALIGNMENT. Thus an annoying chunk of code is required to
  upload row-padded images to Vulkan.
+
_Resolved:_ Remove this and cube padding. Formats that would need
padding have texel sizes that are less than 4 bytes so no benefit
is obtained by starting cube faces or rows of such images at 4-byte
multiples.

Should we require content checksums anywhere?::
  _Discussion:_ Modern transmission mechanisms, e.g, HTTP2, provide good
  robustness so checksums are less important than they used to be. Some
  supercompressions schemes have checksum which may be optional.
+
_Resolved:_ No. We can rely on modern transmission mechanisms. However if
the supercompression scheme includes a checksum readers should verify
it.

== References
[bibliography]
=== Normative References

- [[[OES_ASTC]]]
  {url-khr-reg}/OpenGL/extensions/OES/OES_texture_compression_astc.txt[GL_OES_texture_compression_astc].
Sean Ellis, et al. The Khronos Group, July 2016.

////
// "L." after the doc. title is to make the correct author name
// L. Peter Deutsch. If I put it at the start of the line following
// the title, Asciidoctor thinks I am trying to make a list.
////
- [[[DEFLATE]]] https://tools.ietf.org/html/rfc1951[DEFLATE Compressed
  Data Format Specification version 1.3 (RFC1951)]. L.
Peter Deutsch. IETF Network Working Group, May 1996.

- [[[KDF12]]] {url-khr-reg}/DataFormat/specs/1.2/dataformat.1.2.html[Khronos
  Data Format Specification 1.2].
Andrew Garrard. The Khronos Group, September 2017.

- [[[OESCPT]]] {url-khr-reg}OpenGL/extensions/OES/OES_compressed_paletted_texture.txt[GL_OES_compressed_paletted_texture].
Aaftab Munshi. The Khronos Group, July 2003.

- [[[OPENGL46]]] {url-khr-reg}OpenGL/specs/gl/glspec46.core.pdf[The
  OpenGL^®^ Graphics System, A Specification (Version 4.6 (Core Profile))].
Mark Segal, Kurt Akeley; Editor: Jon Leech. The Khronos Group, July 2017.

- [[[REGEXP]]] https://www.ecma-international.org/ecma-262/5.1/index.html#sec-15.10[Standard
 ECMA-262 5.1{nbsp}Edition, Section 15.10: RegExp (Regular Expression) Objects].
Ecma International, June 2011.

// "S" after doc title avoids the Asciidoctor list issue.
- [[[RFC2119]]] https://www.ietf.org/rfc/rfc2119.txt[Key words for use in RFCs to
Indicate Requirement Levels]. S.
Bradner. IETF Network Working Group, March 1997.

- [[[VULKAN11]]] {url-khr-vulkan}/specs/1.1/html/vkspec.html[Vulkan^®^
1.1 - A Specification].
The Khronos Group, December 2018.

- [[[VULKAN11EXT]]] {url-khr-vulkan}/specs/1.1-extensions/html/vkspec.html[Vulkan^®^
1.1 - A Specification (with all registered Vulkan extensions)].
The Khronos Group, December 2018.

// "L." & "Y." after doc titles avoid the Asciidoctor list issue.
- [[[ZLIB]]] https://tools.ietf.org/html/rfc1950[ZLib Compressed Data
  Data Format Specification version 3.3 (RFC1950)]. L.
Peter Deutsch, Jean-Loup Gailly. IETF Network Working Group, May 1996.

- [[[ZSTD]]] https://tools.ietf.org/html/rfc8478[Zstandard Compression
and the application/zstd Media Type. (RFC8478)]. Y.
Collet, M. Kucherawy, Ed. Internet Engineering Task Force (IETF), October 2018.

[NOTE]
====
The Vulkan 1.1 references are to living documents that are updated
weekly with corrections, clarifications and, in the case of
<<VULKAN11EXT>>, newly released extensions. References to the
specifications do not imply that KTX header field values are limited
solely to those in the referenced sections or tables. These values
may be supplemented by extensions or new versions.  They also do
not imply that all of the texture types can be loaded in any
particular version of OpenGL {,ES} or Vulkan.
====

[bibliography]
=== Non-Normative References

- [[[RDO]]] https://github.com/[Somewhere].
Rich Geldreich, Jr.

[appendix#formatMapping]
== Mapping of `vkFormat` values

.Mapping of `vkFormat` values to OpenGL, Direct3D and Metal
|====
| |
| |
|====

[appendix]
== Changes compared to KTX

- `vkFormat` added.
- Data format descriptor added.
- Supercompression added.
- OpenGL format information fields removed.
- Swizzle and writer id metadata added.
- Row and cube padding removed.

[discrete]
== Revision History
////
// You must insert a new row containing the current values of the
// revnumber and revdate attributes into the table when creating
// a new revision.
////

[.revhistory,cols="^25,^20,<55",options="header"]
|===
| Document Revision |    Date     | Remark
|      draft0       | 2017-12-08  | First incarnation.
|      draft1       | 2018-01-02  | Update issue discussions and change
                                    OpenGL references to 4.6.
|      draft2       | 2018-02-10  | Clarify relation to Data Format
                                    Descriptor spec. Add global
                                    compression. Update issues.
|      draft3       |  2018-06-14 | Remove `glBaseInternalFormat`. Add
                                    zstd global compression option and
                                    issue 11. Add copyright & license.
|      draft4       |  2018-06-26 | Add acknowledgements.
|      draft5       |  2018-07-26 | Change all size & offset fields to
                                    64-bit. Change global compression to
                                    supercompression. Add
                                    supercompressionGlobalData, level
                                    index and writer id. Define interactions
                                    with paletted textures. Remove
                                    `cubePadding`.
|      draft6       |  2018-10-03 | Remove `rowPadding`. Use registered
                                    trademarks. Improve supercompression
                                    section & add references. Add
                                    internal xrefs. Update issues.
|      draft7       |  2018-10-14 | Answer questions re.
                                    supercompression posed in draft 6 &
                                    finish section. Fix scheme numbers
                                    after ANS removal. Alphabetize
                                    references. Improve wording and
                                    formatting. Change status.
|     {docrev}      |  {revdate}  | Change status back to not ready for
                                    implementation in view of
                                    https://github.com/KhronosGroup/KTX-Specification/issues/8[issue
                                    #8].
|===

[discrete]
== Acknowledgements
Thanks to Manmohan Bishnoi for designing the KTX file and application
icons.

Thanks to Alexey Knyazev for help tightening and simplifying the
specification.

Thanks to David Wilkinson for chairing the effort.

[discrete,.legal]
== License

[.legal]
--
This specification is protected by copyright laws and contains material
proprietary to the Khronos Group, Inc. It or any components may not be
reproduced, republished, distributed, transmitted, displayed, broadcast,
or otherwise exploited in any manner without the express prior written
permission of Khronos Group. You may use this specification for implementing
the functionality therein, without altering or removing any trademark,
copyright or other notice from the specification, but the receipt or
possession of this specification does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell
anything that it may describe, in whole or in part.

This version of the KTX Specification is published and copyrighted by
Khronos^®^, but is not a Khronos ratified specification. Accordingly, it
does not fall within the scope of the Khronos IP policy, except to the
extent, if any, that sections of it are normatively referenced in ratified
Khronos specifications. Such references incorporate the referenced sections
into the ratified specifications, and bring those sections into the scope
of the policy for those specifications.

Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions of
this specification in any fashion, provided that NO CHARGE is made for the
specification and the latest available update of the specification for any
version of the API is used whenever possible. Such distributed specification
may be reformatted AS LONG AS the contents of the specification are not
changed in any way. The specification may be incorporated into a product
that is sold as long as such product includes significant independent
work developed by the seller. A link to the current version of this
specification on the Khronos Group website should be included whenever
possible with specification distributions.

Khronos Group makes no, and expressly disclaims any, representations or
warranties, express or implied, regarding this specification, including,
without limitation, any implied warranties of merchantability or fitness
for a particular purpose or non-infringement of any intellectual property.
Khronos Group makes no, and expressly disclaims any, warranties, express
or implied, regarding the correctness, accuracy, completeness, timeliness,
and reliability of the specification. Under no circumstances will the
Khronos Group, or any of its Promoters, Contributors or Members or
their respective partners, officers, directors, employees, agents, or
representatives be liable for any damages, whether direct, indirect,
special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.

The KTX icon is a trademark of and © 2018, the Khronos Group, Inc. and
may not be used without the written permission of the Khronos Group.

Khronos is registered trademark, SYCL, SPIR, WebGL, EGL, COLLADA,
StreamInput, OpenVX, OpenKCam, glTF, OpenKODE, OpenVG, OpenWF,
OpenSL ES, OpenMAX, OpenMAX AL, OpenMAX IL and OpenMAX DL are
trademarks and WebCL is a certification mark of the Khronos Group
Inc. OpenCL is a trademark of Apple Inc. and OpenGL and OpenML are
registered trademarks and the OpenGL ES and OpenGL SC logos are
trademarks of Silicon Graphics International used under license by
Khronos.  All other product names, trademarks, and/or company names
are used solely for identification and belong to their respective
owners.
--

// vim: filetype=asciidoc ai expandtab tw=72 ts=4 sts=2 sw=2
