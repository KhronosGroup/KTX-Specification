= KTX^™️^ File Format Specification
:author: Mark Callow
:author_org: Edgewise Consulting
:description: Specification for container format for OpenGL^®^ and Vulkan^®^ textures.
:docrev: draft20
:ktxver: 2.0
:revnumber: {ktxver}.{docrev}
:revdate: {docdate}
:version-label: Version
:lang: en
:docinfo1:
:doctype: article
:encoding: utf-8
////
// Choose latexmath. A desire for italicized multi-letter variable
// names and indented blocks, overrides the unreadable equations.
////
:stem: latexmath
// Disabling toc and numbered attributes doesn't work with a2x.
// Use the xsltproc options instead.
:toc!:
// a2x: --xsltproc-opts "--stringparam generate.toc nop"
:numbered:
// a2x: --xsltproc-opts "--stringparam chapter.autolabel 0"
// a2x: --xsltproc-opts "--stringparam section.autolabel 0"
//:max-width: 50em
:data-uri:
:icons: font
:source-highlighter: prettify
:stylesheet: khronos.css
:xrefstyle: full

:url-khr-reg: https://www.khronos.org/registry
:url-khr-vulkan: {url-khr-reg}/vulkan

////
// This part is the Preamble whose 1st 'graph is given [.lead] role
// by default meaning it is rendered in a larger font.  Add [.lead]
// to the other Preamble 'graphs so they match. For all 'graphs in
// preamble to be rendered normally add [.normal] to the first 'graph.
////
*Format Version:* 2.0

[.lead]
*Document Revision:* {docrev}

[.lead]
*Editor:* {author} ({author_org})

[.legal]
© 2018 The Khronos Group Inc. All Rights Reserved. See <<License>>.

[abstract]
== Abstract
The KTX file format, version 2 is a format for storing textures
for OpenGL^®^, OpenGL ES^™️^, Vulkan^®^ and WebGL^™️^ applications.  It is
distinguished by the simplicity of the loader required to instantiate
texture objects from the file contents.

It extends the version 1 format with support for easier loading of Vulkan
textures, easier use by non-OpenGL and non-Vulkan applications, support
for streaming and supercompression.

[discrete]
=== Status of this document

Ready for trial implementation. Be aware that changes may be made
if issues are discovered during trial. In particular changes may
be made to the DFD support. KTX2 files to this specification should
_NOT_ be distributed.

== Introduction

This document describes the KTX file format version 2.0, hereafter
referred to as _KTX2_^™️^. KTX2 files are used for storing textures for
use with 3D APIs such as OpenGL, OpenGL ES and Vulkan.

The canonical version of the specification is available in the
Khronos Registry ({url-khr-reg}). The source files used to generate
the specification are stored in the KTX-Specification Repository
(https://github.com/KhronosGroup/KTX-Specification).  The source
repository has a public issue tracker and allows the submission of
pull requests that improve the specification.

KTX2 files can contain almost any of the wide variety of image
formats supported by GPUs. Other specifications wishing to refer
to KTX2 as a container may wish to restrict the range of image
formats or other items that can be used. Such referrers must establish
a way to identify that given KTX2 files are compliant with their
subsets such as by adding a metadata item.

=== Document Conventions

The KTX2 specification is intended for use by both creators and
consumers of KTX2 files forming a contract between these parties.
Specification text may address either party; typically the intended
audience can be inferred from context

==== Normative Terminology

Within this specification, the key words must, required, should,
recommended, may, and optional are to be interpreted as described
in _Key words for use in RFCs to Indicate Requirement Levels_
<<RFC2119>>.  In text addressing creators, their use expresses
requirements that apply to the files produced.  In text addressing
consumers, their use expresses requirements that must be followed
when, e.g, uploading the textures via a 3D API.

==== Admonitions

NOTE: Notes are non-normative and give further background information
such as rationales.

TIP: Tips are non-normative and give helpful suggestions for
implementers or users.

IMPORTANT: Importants are normative and give directions for
implementers.

CAUTION: Cautions are normative and give restrictions that must be
followed.

== File Structure

.Basic Structure
[source,c,subs="+quotes,+attributes,+replacements"]
----
Byte[12] identifier
UInt32 vkFormat
UInt32 typeSize
UInt32 pixelWidth
UInt32 pixelHeight
UInt32 pixelDepth
UInt32 layerCount
UInt32 faceCount
UInt32 levelCount
UInt32 supercompressionScheme

// Index <.>
UInt32 dfdByteOffset
UInt32 dfdByteLength
UInt32 kvdByteOffset
UInt32 kvdByteLength
UInt64 sgdByteOffset
UInt64 sgdByteLength
// Level Index <.>
struct {
    UInt64 byteOffset
    UInt64 byteLength
    UInt64 uncompressedByteLength
} levels[max(1, levelCount)]

// Data Format Descriptor <.>
UInt32 dfdTotalSize
continue
    dfDescriptorBlock dfdBlock
          [.optional]#&#xFE19;#
until dfdByteLength read

// Key/Value Data <.>
continue
    UInt32   keyAndValueByteLength
    Byte     keyAndValue[keyAndValueByteLength]
    align(4) valuePadding <.>
                    [.optional]#&#xFE19;#
until kvdByteLength read
sgdByteLength > 0 ? align(8)

// Supercompression Global Data <.>
Byte supercompressionGlobalData[sgdByteLength]

// Mip Level Array <.>
for each mip_level in levelCount <.>
    Byte     levelImages[bytesOfLevelImages] <.>
end
----
<.> Required. See <<Index>>.
<.> Required. See <<Level Index>>.
<.> Required. See <<Data Format Descriptor>>.
<.> Required. See <<Key/Value Data>>.
<.> `align(n)` is pseudo function that inserts the minimum number
    of 0-filled bytes of padding required to align the following
    item on an n-byte boundary.  where n is the function parameter.
<.> Not required. See <<Supercompression Global Data>>.
<.> Required. See <<Mip Level Array>>.
<.> Replace with 1 if `levelCount` is 0
<.> See the <<levelImages>> below.

After inflation from supercompression or when `supercompressionScheme ==
0`, `levelImages` looks like this:

[[levelImages,levelImages structure]]
.levelImages Structure
[source, c]
----
align( lcm(texel block size, 4) ) mipPadding <1>
for each layer in max(1,layerCount)
   for each face in faceCount
       for each z_slice_of_blocks in num_blocks_z <2>
           for each row_of_blocks in num_blocks_y <2>
               for each block in num_blocks_x <2>
                   Byte data[format-specific-number-of-bytes] <3>
               end
           end
       end
   end
end
----
<1> See <<mipPadding>>.
<2> See <<levelImages_defs,the definitions>> below.
<3> Rows of uncompressed texture images must be tightly packed,
    equivalent to a `GL_UNPACK_ALIGNMENT` of 1.

[[levelImages_defs]]In the `levelImages` loops above,

[stem]
// num_blocks_z = max(1, ceil(pixelDepth / block_depth))
+++++
num\_blocks\_z = \max\left(1, \left\lceil{\frac{pixelDepth}{block\_depth}}\right\rceil\right)
+++++

[stem]
// num_blocks_y = max(1, ceil(pixelHeight / block_height))
+++++
num\_blocks\_y = \max\left(1, \left\lceil{\frac{pixelHeight}{block\_height}}\right\rceil\right)
+++++

[stem]
// num_blocks_x = ceil(pixelWidth / block_width)
+++++
num\_blocks\_x = \left\lceil{\frac{pixelWidth}{block\_width}}\right\rceil
+++++

where _block_depth_, _block_height_, and _block_width_ are `1` for
uncompressed formats and the block size in that dimension for block
compressed formats as given in the format's section of the Khronos
Data Format specification <<KDF13>>.

A _block_ is a single pixel for uncompressed formats and
stem:[block\_width \times block\_height \times block\_depth]
pixels for block compressed formats.

== Field Descriptions

=== identifier
The file identifier is a unique set of bytes that will differentiate the file
from other types of files. It consists of 12 bytes, as follows:
[source,c]
----
Byte[12] FileIdentifier = {
  0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
}
----
This can also be expressed using C-style character definitions as:
[source,c]
----
Byte[12] FileIdentifier = {
  '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\r', '\n', '\x1A', '\n'
}
----
The rationale behind the choice of values in the identifier is based
on the rationale for the identifier in the PNG specification. This
identifier both identifies the file as a KTX file and provides for
immediate detection of common file-transfer problems.

  * Byte [0] is chosen as a non-ASCII value to reduce the probability that a
    text file may be misrecognized as a KTX file.
  * Byte [0] also catches bad file transfers that clear bit 7.
  * Bytes [1..6] identify the format, and are the ASCII values for the string
    "KTX 20".
  * Byte [7] is for aesthetic balance with byte 1 (they are a matching pair
    of double-angle quotation marks).
  * Bytes [8..9] form a CR-LF sequence which catches bad file transfers that
    alter newline sequences.
  * Byte [10] is a control-Z character, which stops file display under MS-DOS,
    and further reduces the chance that a text file will be falsely recognized.
  * Byte [11] is a final line feed, which checks for the inverse of the CR-LF
    translation problem.

=== vkFormat
`vkFormat` specifies the image format using Vulkan `VkFormat` enum
values. It can be any value defined in core Vulkan 1.1 <<VULKAN12>>,
future core versions or by a registered Vulkan extension. Values
defined by core Vulkan 1.1 are given in
{url-khr-vulkan}/specs/1.1/html/vkspec.html#formats-definition[section
32.1 _Format Definition_] of <<VULKAN12>>.  The list of registered
extensions is provided in the {url-khr-vulkan}/#repos[Khronos
Vulkan Registry]. A complete list of values defined by both core
Vulkan 1.1 and extensions can be found in
{url-khr-vulkan}/specs/1.1-extensions/html/vkspec.html#formats-definition[section
37.1 _Format Definition_] of <<VULKAN12EXT>>.

NOTE: The section number given for <<VULKAN12EXT>> is as of this
writing (Vulkan 1.2.133). It is subject to change as future extensions
are added to the document but the link should remain valid as it is to
an internal anchor.

`vkFormat` can be `VK_FORMAT_UNDEFINED` (0) in various cases outlined
within this specification, when the format of the data is a not a
recognized Vulkan format. Information about the data is always given
by the Data Format Descriptor.

Values listed in <<prohibitedFormats>> must not be used nor any
`\*_SCALED_*` formats added in future.  The table in <<formatMapping>>
gives the mapping for all `VkFormat` enum values in Vulkan 1.1 core
and the extensions known at the time of writing, to the equivalent
OpenGL format (internal format, format and type values), DXGI_FORMAT
and MTLPixelFormat. Applications must use these mappings. If
<<formatMapping>> does not have an entry for the value of `vkFormat`,
and a mapping for one or more of the other APIs exists the KTX2
writer must provide that mapping using one or more of the metadata
items described in <<formatMappingMetadata>>. This includes the
case of `VK_FORMAT_UNDEFINED`.

[TIP]
====
Before loading any image, Vulkan loaders should confirm via
`vkGetPhysicalDeviceFormatProperties` that the Vulkan physical
device (`VkDevice`) supports the the intended use of the format.

Vulkan applications using a core Vulkan format whose name has the
`_BLOCK` suffix must ensure they enable the corresponding
`textureCompression*` physical device feature at `VkDevice` creation
time. Those using formats defined by extensions must ensure they
enable the defining extension at `VkDevice` creation time.

Vulkan applications handling textures whose formats are not known at
`VkDevice` creation time are recommended to enable all available texture
compression features and format defining extensions when creating a
device.
====

[width=50%,align=center,cols="<,^",options=header]
[[prohibitedFormats]]
.Prohibited Formats
|===
| Format Name                          | Value
| VK_FORMAT_A8B8G8R8_UNORM_PACK32      | 51
| VK_FORMAT_A8B8G8R8_SNORM_PACK32      | 52
| VK_FORMAT_A8B8G8R8_UINT_PACK32       | 55
| VK_FORMAT_A8B8G8R8_SINT_PACK32       | 56
| VK_FORMAT_A8B8G8R8_SRGB_PACK32       | 57
| VK_FORMAT_R8_USCALED                 | 11
| VK_FORMAT_R8_SSCALED                 | 12
| VK_FORMAT_R8G8_USCALED               | 18
| VK_FORMAT_R8G8_SSCALED               | 19
| VK_FORMAT_R8G8B8_USCALED             | 25
| VK_FORMAT_R8G8B8_SSCALED             | 26
| VK_FORMAT_B8G8R8_USCALED             | 32
| VK_FORMAT_B8G8R8_SSCALED             | 33
| VK_FORMAT_R8G8B8A8_USCALED           | 39
| VK_FORMAT_R8G8B8A8_SSCALED           | 40
| VK_FORMAT_B8G8R8A8_USCALED           | 46
| VK_FORMAT_B8G8R8A8_SSCALED           | 47
| VK_FORMAT_A8B8G8R8_USCALED_PACK32    | 53
| VK_FORMAT_A8B8G8R8_SSCALED_PACK32    | 54
| VK_FORMAT_A2R10G10B10_USCALED_PACK32 | 60
| VK_FORMAT_A2R10G10B10_SSCALED_PACK32 | 61
| VK_FORMAT_A2B10G10R10_USCALED_PACK32 | 66
| VK_FORMAT_A2B10G10R10_SSCALED_PACK32 | 67
| VK_FORMAT_R16_USCALED                | 72
| VK_FORMAT_R16_SSCALED                | 73
| VK_FORMAT_R16G16_USCALED             | 79
| VK_FORMAT_R16G16_SSCALED             | 80
| VK_FORMAT_R16G16B16_USCALED          | 86
| VK_FORMAT_R16G16B16_SSCALED          | 87
| VK_FORMAT_R16G16B16A16_USCALED       | 93
| VK_FORMAT_R16G16B16A16_SSCALED       | 94
|===

[NOTE]
.Rationale
====
The A8B8G8R8*PACK32 formats are prohibited because the end result
is the same regardless of whether the data is treated as packed
into 32-bits or as the equivalent R8G8B8A8 format, i.e. as an array
of 4 bytes, so a Data Format Descriptor cannot distinguish between
these cases.

The \*SCALED* formats are prohibited because they are intended for
vertex data, very few, if any, implementations support using them
for texturing and a Data Format Descriptor cannot distinguish
these from `int` values having the same bit pattern.
====

[CAUTION]
.Legacy Formats
====
The legacy OpenGL & OpenGL ES formats specified by the following
extensions, do not have equivalent Vulkan formats and are not
supported.

- OES_compressed_paletted_texture
- AMD_compressed_3DC_texture
- AMD_compressed_ATC_texture
- 3DFX_texture_compression_FXT1
- EXT_texture_compression_latc

Only a few of these formats can be described without an extended
Data Format Descriptor so `VK_FORMAT_UNDEFINED` must not be used
as a workaround.

This is felt to be an acceptable trade-off for simplifying this
specification as the formats are not in wide use and applications
needing them can use KTX version 1.
====

==== Depth and Stencil Formats
Despite Vulkan requiring separate uploads of depth and stencil
components, combined depth/stencil pixel formats can be used with KTX.
[NOTE]
.Rationale
====
Other GPU APIs support combined uploads and given KTX data alignment it's
trivial to upload components separately in Vulkan.
====

Depth or stencil formats cannot be used for 3D textures.

`VK_FORMAT_D16_UNORM_S8_UINT` is defined as two 16-bit words per texel.
The first word contains the D16 value. The second word contains the S8
value in the eight LSBs and zeros in the eight MSBs.

`VK_FORMAT_D24_UNORM_S8_UINT` is defined as one 32-bit word per texel
with the S8 value in the eight LSBs of the word and the D24 value in the MSBs.

`VK_FORMAT_X8_D24_UNORM_PACK32` is defined as one 32-bit word per texel
with the D24 value in the LSBs of the word and zeros in the eight MSBs.

`VK_FORMAT_D32_SFLOAT_S8_UINT` is defined as two 32-bit words per
texel.  The first word contains the floating-point D32 value. The
second word contains the S8 value in the eight LSBs and zeros in
the MSBs.

`VK_FORMAT_S8_UINT`, `VK_FORMAT_D16_UNORM`, and `VK_FORMAT_D32_SFLOAT`
are defined as in <<VULKAN12EXT>>.

=== typeSize
`typeSize` specifies the size of the data type in bytes used to
upload the data to a graphics API. When `typeSize` is greater than
1, software on big-endian systems must endian convert all image
data since it is little-endian. When format is `VK_FORMAT_UNDEFINED`,
`typeSize` must equal 1. For formats whose Vulkan names have the
suffix `_BLOCK` it must equal 1. For formats with the suffix `_PACKxx`
it must equal the value of stem:[xx / 8]. For unpacked formats,
except combined depth/stencil formats, it must equal the number of
bytes needed for a single component which can be derived from the
format name. E.g for `VK_FORMAT_R16G16B16_UNORM` it will be stem:[16
/ 8].  This means it will equal 1 for any format with 8-bit components.
For `VK_FORMAT_D16_UNORM_S8_UINT`, using the layout defined in this
specification, the value will be 2 and for the other combined
depth/stencil formats the value will be 4.

[NOTE]
.Rationale
====
Although `typeSize` can be calculated from the Data Format Descriptor
and big-endian machines are in the minority we have chosen to provide
a useful piece of data instead of the 4 bytes of padding that would
otherwise be needed for proper alignment of `sgdByteOffset`.
====

=== pixelWidth, pixelHeight, pixelDepth [[dimensions]]
The size of the texture image for level 0, in pixels.

Image dimensions must adhere to format-specific requirements, including:

* width and height being multiples of 4 for BCn and ETC1/ETC2/EAC formats;
* width, height, and depth being multiples of the corresponding block size
dimensions for ASTC formats;
* various restrictions for PVRTC formats (see <<PVRTC>>, <<PVRTC1_OES>>, and
<<PVRTC2_OES>>).

For 1D textures, `pixelHeight` and `pixelDepth` must be 0.

For 2D and cubemap textures, `pixelDepth` must be 0.

For cubemap textures, `pixelHeight` must be equal to `pixelWidth`.

`pixelWidth` cannot be 0.

`pixelDepth` must be 0 for depth or stencil formats.

=== layerCount
`layerCount` specifies the number of array elements. If
the texture is not an array texture, `layerCount` must
equal 0.

Although current graphics APIs do not support 3D array textures, KTX
files can be used to store them.

Refer to <<_texture_type>> for more details about valid values.

=== faceCount
`faceCount` specifies the number of cubemap faces. For cubemaps and
cubemap arrays this must be 6. For non cubemaps this must be 1.
Cubemap faces are stored in the order: +X, -X, +Y, -Y, +Z, -Z.

As prescribed by the Vulkan and OpenGL specifications, all faces
must have a right-down orientation, i.e., an upper left origin, and
must be arranged using a left-handed coordinate system with +Y up.
For example in an outdoor scene, the +Y face must be the sky.  When
facing in the scene what is shown in the +Z face, what is on the
left must be shown in the -X face and what is on the right in the
+X face.  See the identical face selection tables and the equations
for calculating (s, t) in
{url-khr-vulkan}/specs/1.2-extensions/html/vkspec.html#_cube_map_face_selection_and_transformations[section
15.5.3 Cube Map Face Selection and Transformations] of <<VULKAN12>>
and
{url-khr-reg}/OpenGL/specs/gl/glspec46.core.pdf#nameddest=section-8.13[section
8.13 Cube Map Texture Selection] of <<OPENGL46>>.

[TIP]
====
OpenGL has a right-handed coordinate system. Therefore when using a
skybox cube's coordinates as the uvw coordinates for sampling a cubemap
those coordinates must first be transformed to a left-handed system by
multiplying the Z coordinate by -1. Failure to do this will result in
the displayed scene being a mirror image of reality, a common error in
samples found on the web.

While Vulkan has a left-handed coordinate system, +Y is down, therefore
skybox coordinates must be rotated 180 degrees around the X axis before
they are used to sample a cubemap. Failure to do this will result in the
scene being upside down.
====

Applications wanting to store incomplete cubemaps should flatten faces
into a 2D array and use the metadata described in <<KTXcubemapIncomplete>>
to signal which faces are present.

=== levelCount
`levelCount` specifies the number of levels in the <<_mip_level_array,_Mip
Level Array_>> and, by extension, the number of indices in the
`<<_level_index,Level Index>>` array.  A KTX file does not need to
contain a complete mipmap pyramid.  Mip level data is ordered from
the level with the smallest size images, stem:[level_p] to that
with the largest size images, stem:[level_{base}] where stem:[p =
levelCount - 1] and stem:[base = 0].  stem:[level_p] must not be
greater than the maximum possible, stem:[level_{max}], where

[stem]
// max = floor(log2(max(pixelWidth, pixelHeight, pixelDepth)))
+++++
max = \lfloor\log _2\left(\max\left(pixelWidth, pixelHeight, pixelDepth\right)\right)\rfloor
+++++

stem:[levelCount = 1] means that a file contains only the
base level and the texture isn't meant to have other levels. E.g.,
this could be a LUT rather than a natural image.

stem:[levelCount = 0] is allowed, except for block-compressed
formats, and means that a file contains only the base level and
consumers, particularly loaders, should generate other levels if
needed.

=== supercompressionScheme
`supercompressionScheme` indicates if a supercompression scheme has
been applied to the data in `<<_levelimages, levelImages>>`.  It
must be one of the values from <<supercompressionSchemes>>. A value
of `0` indicates no supercompression.

[width=100%,align=center,cols="^22,<18,<30,<30",options=header]
[[supercompressionSchemes]]
.Supercompression Schemes
|===
| Scheme Id            | Scheme Name     | Level Data Format  | Global Data Format
| 0                    | None            |   n/a              | n/a
| 1                    | Basis Universal |  <<BASISU>>        | <<basisu_gd,BasisU Global Data>>
| 2                    | Zstandard       |  <<RFC8478>>       | T.B.D
| 3･･･0xffff           | Reserved^1^     |                    |
| 0x10000･･･0x1ffff    | Reserved^2^     |                    |
| 0x20000･･･0xffffffff | Reserved^3^     |                    |
|===

[small]
1. Reserved for KTX use.
2. Reserved for vendor compression schemes. A registry will be
   established from which vendors can request assignment of values
   thus avoiding conflicts.
3. Reserved. Do not use.

The supercompression scheme is applied independently to each mip
level to permit streaming and random access to the levels. The
format of the data in `<<_levelimages,levelImages>>` for a scheme
is specified in the reference given in the _Level Data Format_
column of <<supercompressionSchemes>>.

Schemes that require data global to all levels can store it as
described in `<<supercompressionGlobalData>>`. Currently only Basis
Universal uses global data. The format of the global data for a scheme
is specified in the reference given in the _Global Data Format_
column of <<supercompressionSchemes>>.

When a supercompression scheme is used, the image data must be
inflated from the scheme prior to GPU sampling.

[TIP]
====
LZW-style lossless supercompression, e.g, scheme 2, is
generally ineffective on the block-compressed data of GPU texture
formats. It is best reserved for use with uncompressed texture
formats or with block-compressed data that has been specially
optimized such as by _Rate Distortion Optimization_ mode <<RDO>>.

Basis Universal internally uses some block-compressed texture formats
and includes Rate Distortion Optimization. Encoding to the internal
format is combined with supercompression. Therefore it is applicable
only to uncompressed images.
====

==== Scheme Notes (Normative)
===== Basis Universal
* `<<_vkformat,vkFormat>>` must be `VK_FORMAT_UNDEFINED` (0x00).
  The <<_data_format_descriptor,_Data Format Descriptor_>> must
  retain the pre-deflation color space information and indicate
  which color and alpha components are present.
  See <<DFD for Supercompressed Data>>.

* `<<_levelsp_uncompressedbytelength,levels[p].uncompressedByteLength>>`
  must be 0.

[NOTE]
.Rationale
====
The Basis Universal encoder combines encoding to a block-compressed
format, chosen for ease of transcoding, with deflation. The transcoder
combines inflation back to the internal block-compressed format
with transcoding to one of many possible other block compressed
formats. There is therefore no common pre- and post-supercompression
format.
====

===== Zstandard
* Only _Zstandard_ frames are required. Inflators may skip _Skippable_
  frames.

* Checksums are optional. If a checksum is present, inflators should
  verify it.

* `<<_vkformat,vkFormat>>` must retain the pre-deflation value.
  The <<_data_format_descriptor,_Data Format Descriptor_>> must
  retain pre-deflation color space information and indicate which
  components are present. See <<DFD for Supercompressed Data>>.

=== Index
An index giving the byte offsets from the start of the file and byte
sizes of the various sections of the KTX file.

==== dfdByteOffset
The offset from the start of the file of the
`<<_dfdtotalsize,dfdTotalSize>>` field of the
<<_data_format_descriptor,_Data Format Descriptor_>>.

==== dfdByteLength
The total number of bytes in the <<_data_format_descriptor,_Data
Format Descriptor_>> including the `<<_dfdtotalsize,dfdTotalSize>>`
field. `dfdByteLength` must equal
`<<_dfdtotalsize,dfdTotalSize>>`.

[NOTE]
====
This field is not necessary. Since no padding is needed for DFDs
the value is easily calculated from the offsets. However, if it is
removed, we would need 4 bytes of padding instead for proper alignment
of `supercompressionGlobalData`. Retaining it means all sections of
the file can be handled uniformly.
====

==== kvdByteOffset
An arbitrary number of <<_keyvalue_data,key/value pairs>> may
follow the Index. These can be used to encode any arbitrary data.
The `kvdByteOffset` field gives the offset of this data, i.e.
that of first key/value pair, from the start of the file.  The value
must be 0 when `kvdByteLength` = 0.

==== kvdByteLength
The total number of bytes of key/value data including all
`<<_keyandvaluebytelength,keyAndValueByteLength>>` fields, all
`<<_keyandvalue,keyAndValue>>` fields and all
`<<_valuepadding,valuePadding>>` fields.

==== sgdByteOffset
The offset from the start of the file of
`<<_supercompressionglobaldata,supercompressionGlobalData>>`. The
value must be 0 when `sgdByteLength` = 0.

==== sgdByteLength
The number of bytes of
`<<_supercompressionglobaldata,supercompressionGlobalData>>`. For
supercompression schemes for which no reference is provided in the
_Global Data Format_ column of <<supercompressionSchemes>>.  the
value must be 0.

==== Level Index
An array, `levels`, giving the offset from the start of the file and
compressed and uncompressed byte sizes of the image data for each
mip level within the <<_mip_level_array,_Mip Level Array_>> The array is ordered
starting with stem:[level_{base}] (the level with the largest size images)
at index _0_. Image for stem:[level_p] will be found at index _p_.

===== levels[p].byteOffset

The offset from the start of the file of the first byte of image data
for mip level _p_. It is the offset of the first byte after any
`<<_mippadding,mipPadding>>`.

===== levels[p].byteLength

The total size of the data for supercompressed mip level _p_.

`levels[p].byteLength` is the number of bytes of pixel data in
LOD stem:[level_p]. This includes all z slices, all faces, all rows
(or rows of blocks) and all pixels (or blocks) in each row for the
mip level.

The total size of the image data from
stem:[levels[numLevels-1\].byteOffset] (i.e., after the first
`mipPadding`, if any) until the end of the file is:
[stem]
+++++
levels[0].byteLength +
\sum_{p=1}^{numLevels-1}
\left\lceil{\frac{levels[p].byteLength}{requiredAlignment}}\right\rceil
\times requiredAlignment
+++++
where
[stem]
+++++
numLevels = \max\left(1, levelCount\right)
+++++
and
[stem]
+++++
requiredAlignment =
  \begin{cases}
    lcm(texel\ block\ size, 4)      & (\text{supercompressionScheme} = 0) \\
    1                               & (\text{supercompressionScheme} \neq 0)
  \end{cases}
+++++
_texel block size_ is defined in <<mipPadding>>.

===== levels[p].uncompressedByteLength

`levels[p].uncompressedByteLength` is the number of bytes of pixel
data in LOD stem:[level_p] after reflation from supercompression.
This includes all z slices, all faces, all rows (or rows of blocks)
and all pixels (or blocks) in each row for the mipmap level. When
`supercompressionScheme == 0`,
`<<_levelsp_bytelength,levels[p].byteLength>>` must have the same
value as this.   When `supercompressionScheme == 1`, Basis Universal,
the value must be 0.

The value of a level's `uncompressedByteLength` must satisfy the
following condition:
[listing]
----
uncompressedByteLength % (faceCount * max(1, layerCount)) == 0
----

[TIP]
====
In versions of OpenGL < 4.5 and in OpenGL ES, faces of non-array
cubemap textures (any texture where `faceCount` is 6 and
`layerCount` is 0) must be uploaded individually. Loaders
wishing to minimize the size of their intermediate buffers may want
to read the faces individually rather then as a block of size
`level[n].uncompressedByteLength`.
====

=== Data Format Descriptor
The Data Format Descriptor (_dfDescriptor_) describes the layout
of the texel blocks in `data`.  The full specification for this is
found in the _Khronos Data Format Specification_ version 1.3
<<KDF13>>.

The dfDescriptor is partially expanded in this specification in
order to provide sufficient information for a KTX2 file to be parsed
without having to refer to <<KDF13>>. It consists of a total size
field and one or more Descriptor Blocks (_dfDescriptorBlock_)
described below.

[NOTE]
.Rationale
====
A _dfDescriptor_ is useful in the following cases:

* precise color management using the descriptor's color space
  information,
* easier use of the images by non-OpenGL and non-Vulkan applications.
  There will be no need for large tables to interpret format enums.
====

==== Restrictions
The following restrictions must be obeyed when setting the fields of a
_dfDescriptorBlock_.

* The value of `<<_vkformat,vkFormat>>` and the image data must
  never contradict the DFD and, vice-versa, the DFD must not contradict
  `<<_vkformat,vkFormat>>`. Supercompression schemes > 1 are an
  exception to this rule. In those cases the DFD will not be that for
  the `<<_vkformat,vkFormat>>` value. Thus the value of `vkFormat` can
  be used as a shortcut. Only when it is `VK_FORMAT_UNDEFINED`, does an
  application need to utilize sample information from the DFD. (In this
  case contradiction is impossible.)
* `colorModel` must be `KHR_DF_MODEL_RGBSDA`, `KHR_DF_MODEL_YUVSDA`
  or one of the block compressed color models listed in <<KDF13>> Section
  5.6 or its successors, currently `KDF_DF_MODEL_BC1A` to
  `KDF_DF_MODEL_UASTC`.
* `colorPrimaries` may be any of the available values since
  conversion of the selected primaries and white point to a display's
  can be done simply with a 3x3 matrix multiply.

[NOTE]
====
`KHR_DF_PRIMARIES_BT709/SRGB` is recommended for standard dynamic range,
standard gamut images.
====

* `transferFunction` must be `KHR_DF_TRANSFER_LINEAR` or
  `KHR_DF_TRANSFER_SRGB` since these are the only ones supported by the
  vast majority of graphics hardware and correct filtering and blending
  without hardware support is difficult to impossible.
* If `<<_vkformat,vkFormat>>` is one of the `+*_SRGB{,_*}+` formats then
  `transferFunction` must be `KHR_DF_TRANSFER_SRGB` and vice-versa.
  For all other non-YUV formats `transfer_function` must be
  `KHR_DF_TRANSFER_LINEAR`.

[NOTE]
.Editors Note
====
Whether KTX2 will support YUV images is not yet decided.
`transfer_function` restrictions for YUV formats will be updated as
necessary.
====

==== Providing additional information
There is one case where the _dfDescriptorBlock_ can be used to
provide additional information beyond that given by <<_vkformat,vkFormat>>.

Premultiplied Alpha::
  `KHR_DF_FLAG_ALPHA_PREMULTIPLIED` (= 1) can be set in the `flags`
  field if the images' RGB components have been multiplied by their
  alpha components.

==== Special Cases

===== Universal ASTC Format
The Universal ASTC image format (UASTC) can be specified using
`colorModel` `KDF_DF_MODEL_UASTC` (= 166) together with `vkFormat`
`VK_FORMAT_UNDEFINED` (= 0). The DFD must be as described in Section
5.6.14 "KHR_DF_MODEL_UASTC" of <<KDF13>>. Images in this format
must be transcoded to a GPU-supported block-compressed format before
being uploaded to and sampled by a GPU. UASTC images can be
supercompressed with Zstandard (`supercompressionScheme` = 2) with
or without first performing Rate Distortion Optimization. If
supercompression is used, the DFD's `bytesPlane[0-7]` must be set
to 0 as described in the next subsection.

===== DFD for Supercompressed Data
When `<<_supercompressionscheme,supercompressionScheme>> is not 0`
the _dfDescriptorBlock_ must preserve the `colorModel`, `transferFunction`,
`colorPrimaries`, and `flags` of the pre-deflation images - for
Basis Universal (`supercompressionScheme` = 1) the pre-encoding and
deflation images - along with each sample's `channelType` and
qualifiers in order to indicate which components are present in the
deflated images. `bytesPlane[0-7]` must be set to 0 to indicate an
_unsized format_, as described in Section 5.19 "Unsized Formats"
of <<KDF13>>.

For Basis Universal, `texelBlockDimension[0-3]` and each sample's
`bitlength`, `bitOffset`, `sampleLower` and `sampleUpper` must be
0

[IMPORTANT]
====
The DFD must reflect the components provided as input to the
ETC1S/LZ encoder not those of the source image. Therefore, for
example, if the software checks for and removes from source image(s)
alpha channel(s) that are all opaque (1.0) before submitting the
data to the ETC1S/LZ encoder then the DFD must not have a sample
with a channelType that indicates it is alpha.
====

For Zstandard (`supercompressionScheme` = 2) the pre-deflation
values of `texelBlockDimension[0-3]` and each sample's `bitlength`,
`bitOffset`, `sampleLower` and `sampleUpper` must be preserved.

[NOTE]
====
In the event that a block-compressed format is supercompressed, which is
forbidden for Basis Universal, the DFD will reflect the color model of
the block-compressed format most of which have only one or two
components.
====

<<example_rg>> shows a DFD for images that were `VK_FORMAT_R8G8_UNORM`,
before encoding and deflation, i.e. they have two
unsigned 8-bit components.

[[example_rg]]
.Example Unsigned RG descriptor for Basis Universal
[.dfdexample, width=75%]
|================================
32+^| *~++uint32_t++ bit~*
^| ~31~ ^| ~30~ ^| ~29~ ^| ~28~ ^| ~27~ ^| ~26~ ^| ~25~ ^| ~24~ ^| ~23~ ^| ~22~ ^| ~21~ ^| ~20~ ^| ~19~ ^| ~18~ ^| ~17~ ^| ~16~ ^| ~15~ ^| ~14~ ^| ~13~ ^| ~12~ ^| ~11~ ^| ~10~ ^| ~9~ ^| ~8~ ^| ~7~ ^| ~6~ ^| ~5~ ^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
32+^| *_totalSize:_* 60
15+^| *_descriptorType:_* 0 17+^| *_vendorId:_* 0
16+^| *_descriptorBlockSize:_* stem:[24 + (16 \times 2) = 56] 16+^| *_versionNumber:_* 2
8+^| *_flags:_* *++ALPHA_STRAIGHT++* 8+^| *_transferFunction:_*
*++LINEAR++* 8+^| *_colorPrimaries:_* *++BT709++* 8+^| *_colorModel:_*
*++RGBSDA++*
8+^| *_~texelBlockDimension3~_* 8+^| *_~texelBlockDimension2~_* 8+^| *_~texelBlockDimension1~_* 8+^| *_~texelBlockDimension0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
8+^| *_bytesPlane3:_* 0 8+^| *_bytesPlane2:_* 0 8+^| *_bytesPlane1:_* 0 8+^| *_bytesPlane0:_* 0
8+^| *_bytesPlane7:_* 0 8+^| *_bytesPlane6:_* 0 8+^| *_bytesPlane5:_* 0 8+^| *_bytesPlane4:_* 0
^| *_~F~_* ^| *_~S~_* ^| *_~E~_* ^| *_~L~_* 4+^| *_~channelType~_* 24+^| ~Red sample information~
^| 0 ^| 0 ^| 0 ^| 0 4+^| *++RED++* 8+^| *_bitLength:_* 0 16+^| *_bitOffset:_* 0
8+^| *_~samplePosition3~_* 8+^| *_~samplePosition2~_* 8+^| *_~samplePosition1~_* 8+^| *_~samplePosition0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
32+^| *_sampleLower:_* 0
32+^| *_sampleUpper:_* 0
^| *_~F~_* ^| *_~S~_* ^| *_~E~_* ^| *_~L~_* 4+^| *_~channelType~_* 24+^| ~Green sample information~
^| 0 ^| 0 ^| 0 ^| 0 4+^| *++GREEN++* 8+^| *_bitLength:_* 0 16+^| *_bitOffset:_* 0
8+^| *_~samplePosition3~_* 8+^| *_~samplePosition2~_* 8+^| *_~samplePosition1~_* 8+^| *_~samplePosition0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
32+^| *_sampleLower:_* 0
32+^| *_sampleUpper:_* 0
|================================

<<example_rgb>> shows a DFD for images that were `VK_FORMAT_R8G8B8_SNORM`,
before deflation, i.e. have 3 signed 8-bit components.

[[example_rgb]]
.Example Signed RGB descriptor for Zstandard
[.dfdexample, width=75%]
|================================
32+^| *~++uint32_t++ bit~*
^| ~31~ ^| ~30~ ^| ~29~ ^| ~28~ ^| ~27~ ^| ~26~ ^| ~25~ ^| ~24~ ^| ~23~ ^| ~22~ ^| ~21~ ^| ~20~ ^| ~19~ ^| ~18~ ^| ~17~ ^| ~16~ ^| ~15~ ^| ~14~ ^| ~13~ ^| ~12~ ^| ~11~ ^| ~10~ ^| ~9~ ^| ~8~ ^| ~7~ ^| ~6~ ^| ~5~ ^| ~4~ ^| ~3~ ^| ~2~ ^| ~1~ ^| ~0~
32+^| *_totalSize:_* 76
15+^| *_descriptorType:_* 0 17+^| *_vendorId:_* 0
16+^| *_descriptorBlockSize:_* stem:[24 + (16 \times 3) = 72] 16+^| *_versionNumber:_* 2
8+^| *_flags:_* *++ALPHA_STRAIGHT++* 8+^| *_transferFunction:_*
*++LINEAR++* 8+^| *_colorPrimaries:_* *++BT709++* 8+^| *_colorModel:_* *++RGBSDA++*
8+^| *_~texelBlockDimension3~_* 8+^| *_~texelBlockDimension2~_* 8+^| *_~texelBlockDimension1~_* 8+^| *_~texelBlockDimension0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
8+^| *_bytesPlane3:_* 0 8+^| *_bytesPlane2:_* 0 8+^| *_bytesPlane1:_* 0 8+^| *_bytesPlane0:_* 0
8+^| *_bytesPlane7:_* 0 8+^| *_bytesPlane6:_* 0 8+^| *_bytesPlane5:_* 0 8+^| *_bytesPlane4:_* 0
^| *_~F~_* ^| *_~S~_* ^| *_~E~_* ^| *_~L~_* 4+^| *_~channelType~_* 24+^| ~Red sample information~
^| 0 ^| 1 ^| 0 ^| 0 4+^| *++RED++* 8+^| *_bitLength:_* 7 16+^| *_bitOffset:_* 0
8+^| *_~samplePosition3~_* 8+^| *_~samplePosition2~_* 8+^| *_~samplePosition1~_* 8+^| *_~samplePosition0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
32+^| *_sampleLower:_* -127
32+^| *_sampleUpper:_* 127
^| *_~F~_* ^| *_~S~_* ^| *_~E~_* ^| *_~L~_* 4+^| *_~channelType~_* 24+^| ~Green sample information~
^| 0 ^| 1 ^| 0 ^| 0 4+^| *++GREEN++* 8+^| *_bitLength:_* 7 16+^| *_bitOffset:_* 8
8+^| *_~samplePosition3~_* 8+^| *_~samplePosition2~_* 8+^| *_~samplePosition1~_* 8+^| *_~samplePosition0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
32+^| *_sampleLower:_* -127
32+^| *_sampleUpper:_* 127
^| *_~F~_* ^| *_~S~_* ^| *_~E~_* ^| *_~L~_* 4+^| *_~channelType~_* 24+^| ~Blue sample information~
^| 0 ^| 1 ^| 0 ^| 0 4+^| *++BLUE++* 8+^| *_bitLength:_* 7 16+^|
*_bitOffset:_* 16
8+^| *_~samplePosition3~_* 8+^| *_~samplePosition2~_* 8+^| *_~samplePosition1~_* 8+^| *_~samplePosition0~_*
8+^| 0 8+^| 0 8+^| 0 8+^| 0
32+^| *_sampleLower:_* -127
32+^| *_sampleUpper:_* 127
|================================

==== dfdTotalSize
Called `total_size` in <<KDF13>>, `dfdTotalSize` indicates the total
number of bytes in the _dfDescriptor_ including `dfdTotalSize` and
all `dfdBlock` fields.  `<<_dfdbytelength,dfdByteLength>>`
must equal `dfdTotalSize`.

If
[stem]
+++++
dfdTotalSize \neq kvdByteOffset - dfdByteOffset
+++++
the file is invalid.

[NOTE]
====
`dfdTotalSize` is included so that the KTX file contains a complete
descriptor as defined in <<KDF13>>.
====

==== dfdBlock
A `Descriptor Block` as defined in <<KDF13>>, the high-order 16
bits of its first UInt32 are the `descriptor_type` and the high-order
16 bits of the second UInt32 are the `descriptor_block_size`.
`descriptor_block_sizes` are mandated to be multiples of 4
which guarantees that the following `keyAndValueByteLength`
will be aligned in a 32-bit word.

=== Key/Value Data
Key/Value data consists of a set of key/value pairs. The number of
pairs is such that
[stem]
+++++
\sum_{i=0}^{n-1}
\left\lceil{\frac{keyAndValueByteLength[i]}{4}}\right\rceil \times 4
+ n \times 4 = kvdByteLength.
+++++

Any file that does not meet the above condition is invalid.

KTX2 editors must preserve any key/value data they do not understand
or which is not modified by the user.

Key/value data must be written to the file sorted by the Unicode
code points of the keys starting from a key's first character.

Keys must not appear more than once.

==== keyAndValueByteLength
The number of bytes of combined key and value data in one key/value
pair. This includes the size of the key, the required NUL byte
terminating the key, and all the bytes of data in the value. If the
value is a UTF-8 string it should be NUL terminated and
`keyAndValueByteLength` must include the NUL character (but code
that reads KTX files must not assume that value fields are NUL
terminated). `keyAndValueByteLength` does not include the bytes in
`<<_valuepadding,valuePadding>>`.

`keyAndValueByteLength` must be at least 2, that is a 1 byte key plus
its NUL terminator.

==== keyAndValue
`keyAndValue` contains 2 separate sections. First it contains a key
encoded in UTF-8 without a byte order mark (BOM). The key must be
terminated by a NUL character (a single 0x00 byte). Keys that begin
with the 3 ASCII characters 'KTX' or 'ktx' are reserved and must
not be used except as described by this specification (this version
of the KTX spec. defines eight keys). Immediately following the NUL
character that terminates the key is the Value data.

The Value data may consist of any arbitrary data bytes. Any byte
value is allowed. It is encouraged that the value be a NUL terminated
UTF-8 string without a BOM, but this is not required.

If the Value data is binary, it is a sequence of bytes rather than
of words. It is up to the vendor defining the key to specify how
those bytes are to be interpreted. If any bytes encode multi-byte
numbers they must be in little-endian order and, if such a number
appears at the start of the Value data, the key length including
its terminating NUL must be a multiple of the number of bytes in
the number so that the number will be properly aligned.

If the Value data is a string then the NUL termination, if present,
must be included in `keyAndValueByteLength` (but programs that read
KTX files must not rely on NUL termination).

==== valuePadding
Contains between 0 and 3 bytes of value `0x00` to ensure that the
byte following the last byte in `valuePadding` is at a file offset
that is a multiple of 4. This ensures that every `keyAndValueByteLength`
field is 4-byte aligned. This padding is included in the
`<<_kvdbytelength,kvdByteLength>>` field but not the
individual `keyAndValueByteLength` fields.

=== Supercompression Global Data
==== supercompressionGlobalData
An array of data used by certain supercompression schemes that must
be available before any mip level can be inflated. Must start on
the next 8-byte boundary following the key/value data. For some
schemes, the specification for this data block is given below.

[#basisu_gd]
==== Basis Universal Global Data

Basis Universal combines encoding to a block-compressed format with
lossless supercompression.  The block-compressed format is chosen
such that it can be easily transcoded to various GPU-native
block-compressed formats. Typically it is a subset of one of those
formats.  Supercompression is accomplished by processing the
block-compressed representation in preparation for entropy encoding
then Huffman encoding the result.  Basis Universal creates a global
codebook referenced by each supercompressed image that contains
processed endpoint and selector data from the block-compression and
the Huffman tables. The global data block contains this codebook.

It also contains an array of _image descriptors_ with flags for each image
and the offset and length within the image's mip level of the data for
that image.

Basis Universal currently uses ETC1S (a subset of ETC1, see <<KDF13>>)
as its base. Plans are for at least one additional base format to
support higher quality, likely a subset of ASTC (see <<KDF13>>).

The bitstreams for endpoints, selectors, Huffman tables and the image
data are defined in <<BASISU>>. These bitstreams have to be decoded to
reconstruct the base images.

Because ETC1 does not support an alpha component, when ETC1S is the
base, i.e. when `isETC1S` is set in <<_globalflags,globalFlags>>,
images may consist of 1 or 2 _slices_ depending on the pre-deflation
components as detailed below.

_One-component images_ must have the component value replicated in all 3
components of the _rgb_ slice of the compressed data and have no _alpha_
slice.

_Two-component images_ must have the R component replicated in all 3
components of the rgb slice and the G component replicated in all 3
components of the alpha slice.

_Three-component images_ must have their RGB components in the rgb
slice and no alpha slice.

_Four-component images_ must have their RGB components in the rgb slice
and the alpha component replicated in all 3 components of the alpha
slice.

TIP: KTX writers may map components of their original input images into
the RGB and A components of the supercompressed image in any way choose.
They may also offer an option to apply KTXswizzle metadata prior to
supercompressing an uncompressed KTX2 file.

The structure of the global data is shown below.

.Basis Universal Global Data Structure
[source,c,subs="+quotes,+attributes,+replacements"]
----
UInt32 globalFlags;
UInt16 endpointCount;
UInt16 selectorCount;
UInt32 endpointsByteLength;
UInt32 selectorsByteLength;
UInt32 tablesByteLength;
UInt32 extendedByteLength;

ImageDesc[imageCount] imageDescs;

Byte[endpointsByteLength] endpointsData
Byte[selectorsByteLength] selectorsData
Byte[tablesByteLength] tablesData
Bytes[extendedByteLength] extendedData
----

`ImageDesc` is the following structure.

.ImageDesc
[source,c]
----
UInt32 imageFlags
UInt32 rgbSliceByteOffset
UInt32 rgbSliceByteLength
UInt32 alphaSliceByteOffset
UInt32 alphaSliceByteLength
----

Descriptions in the `imageDescs` array are in the order layer, face and z_slice as if
arranged by the following pseudo code.
[source,c]
----
for each level in max(levelCount, 1)
    for each layer in max (layerCount, 1)
        for each face in faceCount // 1 or 6
            for each z_slice in max((pixelDepth of level), 1)
----

`imageCount` is the total number of images in the Mip Level Array.

[TIP]
====
`imageCount` may be calculated as follows:
[source,c]
----
int imageCount = max(layerCount, 1) * faceCount * layerPixelDepth;

// where layerPixelDepth can be derived as
int layerPixelDepth = max(pixelDepth, 1);
for(int i = 1; i < levelCount; i++)
    layerPixelDepth += max(pixelDepth >> i, 1);
----
====

===== globalFlags
Flags with information that is the same for all images. The following
flags are valid:
[source,c]
----
isETC1S = 0x01
hasAlphaSlices = 0x04
----

For current Basis Universal, `isETC1S` must be set. The flag is provided
together with `extendedData` to enable future enhancements such as HDR
support.

`hasAlphaSlices` indicates the Basis data contains alpha slices.

NOTE: This does not necessarily mean the texture has an alpha component.

===== endpointCount
The number of endpoints in <<_endpointsdata,endpointsData>>.

===== selectorCount
The number of selectors in <<_selectorsdata,selectorsData>>.

===== endpointsByteLength
The length of <<_endpointsdata,endpointsData>>.

===== selectorsByteLength
The length of <<_selectorsdata,selectorsData>>.

===== tablesByteLength
The length of <<_tablesdata,tablesData>>.

===== extendedByteLength
The length of <<_extendeddata,extendedData>>. Must be 0 if `isETC1S` is set in flags.

===== ImageDesc
====== imageFlags
Flags giving information about an individual image. The following flag
is valid:
[source,c]
----
isIFrame = 0x02
----

Basis Universal supports inter-frame (video) encoding for 2D slices.
If `isIFrame` is set the image (frame) is an I frame. That is, it
does not refer to the previous image. If unset, the image is a P
frame. If the file is not an _animation sequence_ it must be unset. See
<<Animation Sequence>> for details.

====== rgbSliceByteOffset, rgbSliceByteLength
The offset of the start of the RGB slice within the
<<_levelimages,levelImages>> of its mip level and its byte length.
ahe offset of <<_levelimages,levelImages>> within the file is given
in the <<_level_index,Level Index>>.

====== alphaSliceByteOffset, alphaSliceByteLength
The offset of the start of the alpha slice within the
<<_levelimages,levelImages>> of its mip level and its byte length.

If `hasAlpha` is unset these values must be 0.

===== endpointsData
Compressed endpoints data. The format of this data is described in
T.B.D.

===== selectorsData
Compressed selectors data. The format of this data is described in
T.B.D.

===== tablesData
Huffman tables data. The format of this data is described in T.B.D.

===== extendedData
Extended data. The format of this data is described in T.B.D.

=== Mip Level Array

Mip levels in the array are ordered from the level with the
smallest size images, stem:[level_p] to that with the largest size
images, stem:[level_{base}].

[NOTE]
.Rationale
====
When streaming a KTX file, sending smaller mip levels first can be
used together with, e.g., the `GL_TEXTURE_MAX_LEVEL` and
`GL_TEXTURE_BASE_LEVEL` texture parameters or appropriate region setting
in a `VkCmdCopyBufferToImage`, to display a low resolution image quickly
without waiting for the entire texture data.
====

==== levelImages
`levelImages` is an array of Bytes holding all the image data for a
level. The offset of a level's `levelImages` is provided by the
 <<_level_index,Level Index>>.

When `<<_supercompressionscheme,supercompressionScheme>> != 0` these
bytes are formatted as specified in the scheme documentation.

==== mipPadding
`mipPadding` is between 0 and stem:[lcm(texel\ block\ size, 4) -
1] bytes of value `0x00`. stem:[lcm] is _least common multiple_.
This is only required when
`<<_supercompressionscheme,supercompressionScheme>> == 0`. When
`<<_vkformat,vkFormat>>` is not `VK_FORMAT_UNDEFINED`, _texel block
size_ is as given for the `vkFormat` value in
{url-khr-vulkan}/specs/1.1-extensions/html/vkspec.html#formats-compatibility[section
37.1.6 _Format Compatibility Classes_] of <<VULKAN12EXT>> otherwise
it is 16.

[NOTE]
.Padding Rationale
====
`mipPadding` ensures that data for each mip level is aligned on a
boundary that enables data to be uploaded to a graphics API in bulk
without having to shuffle it around. Among other things, this enables
memory mapped files to be used with some APIs. Vulkan requires data
to be aligned to a texel block size boundary and to a 4-byte boundary
hence the least common multiple requirement.

Since levels after the first will be naturally aligned to their
texel block size, in block-compressed formats because an integral
number of blocks is required regardless of the image size, the
majority of formats will have 0 bytes of padding between levels.
The exception is formats whose texel block size is not a multiple
of 4. Depending on the image size, these may require some `mipPadding`
bytes between levels to meet the alignment requirement.
====

== General comments
=== Endianness
KTX {ktxver} files are little endian. All header fields and the
data for all uncompressed texture formats are stored in little
endian order.  Readers on big-endian machines must endian convert
all header UInt32s and UInt64s and, when <<_typesize,typeSize>> is
greater than 1, all `data` to big endian. The data of block compressed
formats, those ending in `*_BLOCK`, does not need endian converting.

If an application on a big-endian machine intends to use the sample
information in the Data Format Descriptor, the DFD must be rewritten
for the endian-converted `data` as the samples describe the data as
laid out in memory. Sample code for rewriting DFDs is given in
<<Data Format Descriptor Endian Conversion>>.

Writers must endian convert these items to little endian on writing
the file.

=== Packing
Rows of uncompressed pixel data are tightly packed. Each row in
memory immediately follows the end of the preceding row. I.e the
data must be packed according to the rules described in section
8.4.4.1 _Unpacking_ of the OpenGL 4.6 specification <<OPENGL46>>
with `GL_UNPACK_ROW_LENGTH` = 0 and `GL_UNPACK_ALIGNMENT` = 1.

=== Texture Type
The type of texture can be determined from the following table. Any
other combination of parameters makes the KTX file invalid.

[options="header"]
|====
|Type|<<dimensions,pixelWidth>>|<<dimensions,pixelHeight>>|<<dimensions,pixelDepth>>|<<_layercount,layerCount>>|<<_facecount,faceCount>>
|1D           |> 0       |0          |0         |0                    |1
|2D           |> 0       |> 0        |0         |0                    |1
|3D           |> 0       |> 0        |> 0       |0                    |1
|Cubemap      |> 0       |> 0        |0         |0                    |6
|1D Array     |> 0       |0          |0         |> 0                  |1
|2D Array     |> 0       |> 0        |0         |> 0                  |1
|3D Array     |> 0       |> 0        |> 0       |> 0                  |1
|Cubemap Array|> 0       |> 0        |0         |> 0                  |6
|====

=== Animation Sequence
The images of a 2D array texture can be indicated to be the frames
of a short animation sequence by including <<_ktxanimdata,KTXanimData>>
metadata. Valid _animation_ files must have the combination of
parameters outlined in <<Texture Type>> for 2D Array textures in
addition to KTXanimData metadata. <<_layercount,`layerCount`>> is
the number of frames in the video, i.e. layers become the temporal
axis.

TIP: Use of uncompressed images for an animation sequence will not be
memory efficient. Animation sequences should be limited to
block-compressed or, preferably, Basis Universal compressed textures.

== Predefined Key/Value Pairs

=== KTXcubemapIncomplete
A KTX file can be used to store an incomplete cubemap or an array of
incomplete cubemaps. In such a case, `faceCount` must be `1` and
`layerCount` must be equal to the number of faces present
(in case of a single cubemap) or to the number of faces present times
the number of cubemaps (in case of a cubemap array). The faces that are
present must be indicated using the metadata key

-   `KTXcubemapIncomplete`

The value is a one-byte bitfield defined as:

[listing]
-----
00xxxxx1 - +X is present
00xxxx1x - -X is present
00xxx1xx - +Y is present
00xx1xxx - -Y is present
00x1xxxx - +Z is present
001xxxxx - -Z is present
-----

Any value, not matching the mask above is invalid.

At least one face must be present (i.e., value cannot be `0`).

Within the <<levelImages>> structure, faces must be written in the
same order as with complete cubemaps: +X, -X, +Y, -Y, +Z, -Z.

When a texture is a cubemap array, missing/present faces must be
the same for each element.

As with complete cubemaps, `pixelHeight` must be equal to `pixelWidth`.

=== KTXorientation
Texture data in a KTX file are arranged so that the first pixel in
the data stream for each face and/or array element is closest to
the origin of the texture coordinate system. In OpenGL that origin
is conventionally described as being at the lower left, but this
convention is not shared by all image file formats and content
creation tools, so there is abundant room for confusion.

The desired texture axis orientation is often predetermined by,
e.g. a content creation tool's or existing application's use of the
image. Therefore it is strongly recommended that tools for generating
and manipulating KTX files clearly describe their behaviour, and
provide an option to specify the texture axis origin and orientation
relative to the logical orientation of the source image. At minimum
they should provide a choice between top-left and bottom-left as
origin for 2D source images, with the positive S axis pointing
right. Where possible, the preferred default is to use the logical
upper-left corner of the image as the texture origin. Note that
this is contrary to the standard interpretation of GL texture
coordinates. However, most other APIs and the majority of texture
compression tools use this convention.

When writing the logical orientation to the KTX file's metadata,
image manipulation tools and viewers must use the key

-   `KTXorientation`

Note that this metadata affects only the logical interpretation of
the data and has no effect on the mapping from pixels in the file
byte stream to texture coordinates.

The value is a NUL-terminated string formatted depending on the texture type.

[options="header"]
|====
|Type|Format (<<REGEXP>>)
|1D  |`/^[rl]$/`
|2D  |`/^[rl][du]$/`
|3D  |`/^[rl][du][oi]$/`
|====

where

[no-bullet]
- `r` indicates S values increasing to the right
- `l` indicates S values increasing to the left
- `d` indicates T values increasing downwards
- `u` indicates T values increasing upwards
- `o` indicates R values increasing out from the screen (moving towards viewer)
- `i` indicates R values increasing in towards the screen (moving away from viewer)

When a texture is an array, all its elements have the same orientation.

Values not matching the table above are invalid.

It is recommended that viewing and editing tools support at least the following values:

- `rd`
- `ru`
- `rdi`
- `ruo`

Although other orientations can be represented, it is recommended
that tools that create KTX files use only the values listed above
as other values may not be widely supported by other tools.

[#formatMappingMetadata]
=== Format Mapping

When <<formatMapping>> does not have an entry for the value of
`vkFormat`, which will happen for newly added Vulkan formats, the
KTX writer must provide any known mapping via the following key-value
pairs.

==== KTXglFormat

For OpenGL {,ES} the mapping is specified with the key

- `KTXglFormat`

The value is 12 bytes representing 3 Uint32 values:

[source,c]
----
UInt32 glInternalformat
UInt32 glFormat
UInt32 glType
----

For compressed formats, `glFormat` and `glType` must be set to zero;
and `glInternalformat` must be used for providing mapping.

==== KTXdxgiFormat__

For Direct3D the mapping is specified with the key

- `KTXdxgiFormat__`

The value is a UInt32 (4 bytes) giving the format enum value.

==== KTXmetalPixelFormat

For Metal, the mapping is specified with the key

- `KTXmetalPixelFormat`

The value is a UInt32 (4 bytes) giving the format enum value.

=== KTXswizzle

////
[NOTE]
.Differences between OpenGL and Vulkan Swizzle
====
* Vulkan uses an enum, VkComponentSwizzle, with values from 0 (IDENTITY)
  to 6 (SWIZZLE_A). OpenGL uses the values of the existing constants
  GL_RED (0x1903), GL_GREEN (0x1904), GL_BLUE (0x1905), GL_ALPHA (0x1906),
  GL_ZERO (0) and GL_ONE (1).

* OpenGL does not have an identity swizzle.

* Vulkan has a struct VkComponentMapping while OpenGL uses an array of
  component swizzle values.
====
////

Desired component mapping for a texture can be indicated with the key

-   `KTXswizzle`

The value is a four-byte NUL-terminated string formatted as (<<REGEXP>>):

[no-bullet]
-   `/^[rgba01]{4}$/`

where each symbol represents source component (or fixed value) that
is used for red, green, blue, and alpha values, thus `rgba` being
a default swizzling state.

For example, `rg01` means:

- the red and green channels are sampled from the red and green texture
  components respectively;
- the blue channel is set to zero, ignoring texture data;
- the alpha channel is set to one (fully saturated), ignoring texture data.

When a channel is not present in the texture, a value of `0` must be
used for colors (red, green, and blue) and a value of `1` (fully
saturated) must be used for alpha.

This metadata has no effect on depth or stencil texture formats.

==== Common Mappings

Use the following formats and swizzles to map alpha-only, luminance and
luminance-alpha formats.

Alpha8::
`vkFormat`: `VK_FORMAT_R8_UNORM` (9)
 +
`KTXswizzle`: 000r

Luminance8::
`vkFormat`: `VK_FORMAT_R8_UNORM` (9)
 +
`KTXswizzle`: rrr1

Luminance8Alpha8::
`vkFormat`: `VK_FORMAT_R8G8_UNORM` (16)
 +
`KTXswizzle`: rrrg

Loaders may opt to detect these cases and use API-provided enums
when available, e.g. for the first case  `GL_ALPHA8` (when using
compatibility profile), `MTLPixelFormatA8Unorm` or `DXGI_FORMAT_A8_UNORM`.

=== KTXwriter
KTX file writers may, and are strongly encouraged to, identify
themselves by including a value with the key

-   `KTXwriter`

The value can be any UTF-8 string that will uniquely identify the tool
writing the file, for example:

[no-bullet]
-   `AcmeCo TexTool v1.0`

Only the most recent writer should be identified.  Editing tools
must overwrite this value when rewriting a file originally written
by a different tool.

=== KTXastcDecodeMode
By default, ASTC decoders produce pixel values with half-float precision for HDR and
linear LDR blocks. KTX file writers may indicate that the data is compatible with
more compact decoding modes (as defined in <<VULKAN12EXT>>, `VK_EXT_astc_decode_mode`)
by using the key

-   `KTXastcDecodeMode`

The value is a NUL-terminated string.

`rgb9e5` means that pixel values can be decoded with RGB9E5 mode.

`unorm8` (valid only for LDR formats) means that pixel values can
be decoded with UNORM8 mode.

Other values are not allowed.

This metadata entry has no effect on and should not be present in KTX files that
use sRGB transfer function.

This metadata entry has no effect on and should not be present in KTX files that
use non-ASTC formats.

=== KTXanimData
The images of a 2D array texture can be indicated to be the frames of a
short animation by using the key

-   `KTXanimData`

The value is 12 bytes representing 3 Uint32 values:
[source,c]
----
UInt32 duration
UInt32 timescale
UInt32 loopCount
----

`duration` is the number of _time units_ per frame. `timescale` is the
number of _time units_ per 1 second. Thus the duration of a frame in
seconds is stem:[duration / timescale].

`loopCount` indicates how many times to loop the animation. Values are:

[no-bullet]
* 0 - loops infinitely
* 1 - plays once
* n - plays n times

== An example KTX file:

TBC

== IANA Media-Type Registration Information

[.legal]
_Permission is expressly granted to IANA to copy this section as
necessary for managing the MIME types registry._

include::ktx-media-registration.txt[]

== Issues
[qanda]
How to refer to the DF descriptor block?::
  _Discussion:_ There is no such data type as `dfDesriptorBlock` but
  using primitive types would effectively mean repeating the
  definition of a descriptor block here which we do not want to do.
+
_Resolved:_ Show that `dfDescriptorBlock` is used as a shorthand for
<<KDF13>>'s _Descriptor block_.

How to handle endianness of the DF descriptor block?::
  _Discussion_: The DF spec says data structures are assumed to be
  little-endian for purposes of data transfer. This is incompatible
  with the net which is big-endian and incompatible with `endianness`.
  What should we do?
+
_Resolved._All fields and data in KTX files will be little endian as
that is the endianness of the vast majority of machines.

Can we guarantee the DF descriptor blocks are always a multiple of 4 bytes?::
  _Discussion_ The _Khronos Basic Data Format Descriptor Block_ is
  a multiple of 4 bytes (24 + 16 x number of samples). Is there
  anything to require that extensions' block sizes be a multiple of
  4 bytes? Need to maintain alignment.
+
_Resolved:_ The Data Format Specification has been updated to
recommend but not require padding. This spec. will require padding.

Should KTX2 support level sizes > 4GB?::
  _Discussion:_ Users have reported having base levels > 4GB for 3D
  textures.  For this the `imageSize` field needs to be 64-bits. Loaders
  on 32-bit systems will have to ensure correct handling of this and
  check that `imageSize` \<= 4GB, before loading.
+
_Resolved:_ Be future proof and make all image-size related fields 64
bits.

Should KTX2 provide a way to distinguish between rectangle and regular 2D textures?::
  _Discussion:_ The difference is that unnormalized texel coordinates
  are used for sampling via a special sampler type in GLSL and, in the
  case of OpenGL {,ES}, the special TEXTURE_RECTANGLE target is used. If
  needed this could be supported by a metadata item instructing to use
  unnormalized texel coordinates.
+
_Unresolved:_

Should KTX2 provide a way to distinguish between 1D textures and buffer textures?::
  _Discussion:_ The difference is how you use the data in OpenGL.
  With buffer textures the image data is stored in a buffer object.
  Note that a TextureView can be used to give a different view of the
  data so supporting buffer textures probably requires metadata to
  indicate a preferred view as well as metadata to indicate
  the data should be loaded in a buffer.
+
_Unresolved:_

Should KTX2 drop the `gl*` fields?::
  _Discussion:_ Narrowing down and enforcing the valid combinations
  of `glFormat`, `glInternalFormat` and `glType` is fraught with
  issues. The spec. could be simplified by dropping them and having
  only `vkFormat`.  The spec can include a table showing a standard
  mapping from the `vkFormat` value to a `glInternalFormat`,
  `glFormat` and `glType` combination.
+
_Resolved:_ Drop the `gl*` fields. OpenGL and OpenGL ES loaders
can include code to do the mapping based on table which has been
added to the spec. Such code is estimated to be about 6 kbytes.

Use alphanumeric characters or binary values for component swizzles?::
  _Discussion:_ Values in the swizzle metadata could be either a
  character from the set [01rgba] or numeric values corresponding to the
  VkComponentSwizzle enum values from 0 to 6. In the latter case values
  could be expressed in binary or as numeric characters. The
  GL token values have been eliminated from this choice because they
  are not user friendly.
+
_Resolved:_ Use alphanumeric characters from the set [01rgba].

Is anything needed to support sparse textures?::
  _Discussion:_ Sparse textures are provided by the
  `GL_ARB_sparse_textures` extension and are a standard feature of
  Vulkan. Are any additional KTX features needed to support them?
+
_Unresolved:_

Should KTX2 support metadata for effective use of Vulkan SCALED formats?::
  _Discussion:_ Vulkan SCALED formats convert int (or uint) values
  to unnormalized floating point values, equivalent to specifying a
  value of `GL_FALSE` for the `normalized` parameter to
  `glVertexAttribFormat`. Generally when using such data, associated
  scale and bias values are folded into the transformation matrix.
  Should KTX2 specify standard metadata for these?
+
_Resolved:_ No. These formats will not be supported. They are
primarily for vertex data and several Vulkan vendors have said they
can't support them as texture formats. Also a DFD cannot distinguish
these from `int` values having the same bit pattern.

Should the supercompression scheme be applied per-mip-level?::
  _Discussion:_ Should each mip level be supercompressed independently
  or should the scheme, zlib, zstd, etc., be applied to all levels
  as a unit? The latter may result in slightly smaller size though
  that is unclear. However it would also mean levels could not be
  streamed or randomly accessed.
+
_Resolved:_ Yes. The benefits of streaming and random access outweigh
what is expected to be a small increase in size.

Should we remove row padding from uncompressed image data?::
  _Discussion:_ Row padding was added to KTX so that data would have the
  default GL_UNPACK_ALIGNMENT of 4, which was chosen to help speed up DMA
  of rows by the GPU. Modern architectures are apparently not sensitive
  to this as evidenced by Vulkan deliberately omitting any equivalent of
  GL_UNPACK_ALIGNMENT. Thus an annoying chunk of code is required to
  upload row-padded images to Vulkan.
+
_Resolved:_ Remove this and cube padding. Formats that would need
padding have texel sizes that are less than 4 bytes so no benefit
is obtained by starting cube faces or rows of such images at 4-byte
multiples.

Should we require content checksums anywhere?::
  _Discussion:_ Modern transmission mechanisms, e.g, HTTP2, provide good
  robustness so checksums are less important than they used to be. Some
  supercompressions schemes have checksum which may be optional.
+
_Resolved:_ No. We can rely on modern transmission mechanisms. However if
the supercompression scheme includes a checksum readers should verify
it.

Should we use the DFD to indicate the number of components in Basis Universal supercompressed data?::
  _Discussion:_ Basis Universal compressed data may have 1, 2, 3
  or 4 components. The number of components affects the choice of
  transcode target format. The information could be provided within
  the supercompression global data or by the DFD. Currently presence
  of alpha slices, but not necessarily an alpha component, is indicated
  by a flag in the global data. The number of components is needed by
  applications that may have no knowledge of the original images.
+
_Resolved:_ Yes. The supercompression global data gives information
about the Basis Universal compressed data not about the images. The
DFD contains this information prior to supercompression. It makes sense
to preserve it. Implementations will then have a consistent place to
query this information.

== References
[bibliography]
=== Normative References

- [[[BASISU]]]
  https://somewhere/soon/we/hope

- [[[OES_ASTC]]]
  {url-khr-reg}/OpenGL/extensions/OES/OES_texture_compression_astc.txt[GL_OES_texture_compression_astc].
Sean Ellis, et al. The Khronos Group, July 2016.

- [[[KDF13]]] {url-khr-reg}/DataFormat/specs/1.3/dataformat.1.3.html[Khronos
  Data Format Specification 1.3].
Andrew Garrard. The Khronos Group.

- [[[LZMA]]] https://www.7-zip.org/a/lzma-specification.7z[LZMA
  Specification (DRAFT version)] and
  https://www.7-zip.org/sdk.html[LZMA Software Development
  Kit]. Igor Pavlov. June 2015.

- [[[OESCPT]]] {url-khr-reg}/OpenGL/extensions/OES/OES_compressed_paletted_texture.txt[GL_OES_compressed_paletted_texture].
Aaftab Munshi. The Khronos Group, July 2003.

- [[[OPENGL46]]] {url-khr-reg}/OpenGL/specs/gl/glspec46.core.pdf[The
  OpenGL^®^ Graphics System, A Specification (Version 4.6 (Core Profile))].
Mark Segal, Kurt Akeley; Editor: Jon Leech. The Khronos Group, July 2017.

- [[[PVRTC]]]
  {url-khr-reg}/DataFormat/specs/1.3/dataformat.1.3.html#PVRTC["PVRTC
  Compressed Texture Image Formats" chapter, Khronos Data Format
  Specification 1.3].
Andrew Garrard and Imagination Technologies Limited.

- [[[PVRTC1_OES]]] https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt[IMG_texture_compression_pvrtc].
Imagination Technologies Limited, 2005

- [[[PVRTC2_OES]]] https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc2.txt[IMG_texture_compression_pvrtc2].
Imagination Technologies Limited, 2011

- [[[REGEXP]]] https://www.ecma-international.org/ecma-262/5.1/index.html#sec-15.10[Standard
 ECMA-262 5.1{nbsp}Edition, Section 15.10: RegExp (Regular Expression) Objects].
Ecma International, June 2011.

////
// "L." after the doc. title is to make the correct author name
// L. Peter Deutsch. If I put it at the start of the line following
// the title, Asciidoctor thinks I am trying to make a list.
////
- [[[RFC1950]]] https://tools.ietf.org/html/rfc1950[ZLib Compressed Data
  Data Format Specification version 3.3]. L.
Peter Deutsch, Jean-Loup Gailly. IETF Network Working Group, May 1996.

// "L.", "S." and "Y." after doc titles avoid the Asciidoctor list issue.
- [[[RFC1951]]] https://tools.ietf.org/html/rfc1951[DEFLATE Compressed
  Data Format Specification version 1.3]. L.
Peter Deutsch. IETF Network Working Group, May 1996.

- [[[RFC2119]]] https://www.ietf.org/rfc/rfc2119.txt[Key words for use in RFCs to
Indicate Requirement Levels]. S.
Bradner. IETF Network Working Group, March 1997.

- [[[RFC8478]]] https://tools.ietf.org/html/rfc8478[Zstandard Compression
and the application/zstd Media Type.]. Y.
Collet, M. Kucherawy, Ed. Internet Engineering Task Force (IETF), October 2018.

- [[[VULKAN12]]] {url-khr-vulkan}/specs/1.2/html/vkspec.html[Vulkan^®^
1.1 - A Specification].
The Khronos Group, December 2018.

- [[[VULKAN12EXT]]] {url-khr-vulkan}/specs/1.2-extensions/html/vkspec.html[Vulkan^®^
1.1 - A Specification (with all registered Vulkan extensions)].
The Khronos Group, December 2018.

[NOTE]
====
The Vulkan 1.1 references are living documents that are updated
weekly with corrections, clarifications and, in the case of
<<VULKAN12EXT>>, newly released extensions. References to the
specifications do not imply that KTX header field values are limited
solely to those in the referenced sections or tables. These values
may be supplemented by extensions or new versions.  They also do
not imply that all of the texture types can be loaded in any
particular version of OpenGL {,ES} or Vulkan.
====

[bibliography]
=== Non-Normative References

- [[[RDO]]] https://github.com/[Somewhere].
Rich Geldreich, Jr.

[appendix#formatMapping]
== Mapping of `vkFormat` values

CAUTION: This section is non-normative.

CAUTION: Provided mappings for BGR(A) formats are based on non-ES OpenGL specifications. See the relevant OpenGL ES extensions for more options.

CAUTION: Half-Float data type uses different enum values on different OpenGL ES and WebGL versions.

CAUTION: Some vendor-specific extensions (e.g. `GL_NV_depth_buffer_float`) define custom enum values for symbols used in the ratified specifications.

.Mapping of `vkFormat` values to OpenGL, Direct3D and Metal
[%collapsible]
=====
include::formats.json[]
=====

[appendix]
== Changes compared to KTX

- `vkFormat` added.
- OpenGL format information fields removed.
- Data format descriptor added.
- Supercompression added.
- Files always little endian.
- Swizzle and writer id metadata added.
- Row and cube padding removed.

[appendix]
== Data Format Descriptor Endian Conversion

This appendix is informative only.

[source,c]
.Endian converting sample information
----
// To be written.
----

[discrete]
== Revision History
////
// You must insert a new row containing the current values of the
// revnumber and revdate attributes into the table when creating
// a new revision.
////

[.revhistory,cols="^25,^20,<55",options="header"]
|===
| Document Revision |    Date     | Remark
|      draft0       | 2017-12-08  | First incarnation.
|      draft1       | 2018-01-02  | Update issue discussions and change
                                    OpenGL references to 4.6.
|      draft2       | 2018-02-10  | Clarify relation to Data Format
                                    Descriptor spec. Add global
                                    compression. Update issues.
|      draft3       |  2018-06-14 | Remove `glBaseInternalFormat`. Add
                                    zstd global compression option and
                                    issue 11. Add copyright & license.
|      draft4       |  2018-06-26 | Add acknowledgements.
|      draft5       |  2018-07-26 | Change all size & offset fields to
                                    64-bit. Change global compression to
                                    supercompression. Add
                                    supercompressionGlobalData, level
                                    index and writer id. Define interactions
                                    with paletted textures. Remove
                                    `cubePadding`.
|      draft6       |  2018-10-03 | Remove `rowPadding`. Use registered
                                    trademarks. Improve supercompression
                                    section & add references. Add
                                    internal xrefs. Update issues.
|      draft7       |  2018-10-14 | Answer questions re.
                                    supercompression posed in draft 6 &
                                    finish section. Fix scheme numbers
                                    after ANS removal. Alphabetize
                                    references. Improve wording and
                                    formatting. Change status.
|      draft8       |  2018-10-26 | Change status back to not ready for
                                    implementation in view of
                                    https://github.com/KhronosGroup/KTX-Specification/issues/8[issue
                                    #8].
|      draft9       |  2019-02-27 | Use Khronos style sheet. Drop GL
                                    format info. Add index for direct
                                    access to data. Change to little
                                    endian. Specify padding values.
                                    Remove ambiguity and potential
                                    conflicts.
|      draft10      |  2019-03-17 | Add "do not distribute files"
                                    warning to status.
|      draft11      |  2019-06-03 | Add format mapping list. Add
                                    restrictions on DFD use. Remove
                                    bytesOfImageData and
                                    bytesOfUncompressedImageData. Rename
                                    header length and offset fields to
                                    match glTF conventions. Make many
                                    language improvements and fix errors
                                    and typos.
|      draft12      |  2019-06-05 | Change 22 in identifier to 20.
|      draft13      |  2019-11-13 | Rename arrayElementCount. Add ASTC
                                    HDR & 3D enums. Add GL API support
                                    info. Update supercompression info
                                    including documenting BasisU global
                                    data and specifying necessary DFDs.
                                    Fix various bugs.
|      draft14      |  2019-12-07 | Fix typos, contradictions &
                                    omissions. Retain component info and
                                    signed/unsigned-ness in DFD for all
                                    supercompression schemes. Require
                                    metadata key lengths be suitable to
                                    align wide binary numbers and change
                                    KTXanimation to KTXanimData. Require
                                    padding after last mip level and
                                    key/value pair for consistent
                                    handling. Add Metal ASTC HDR
                                    formats.
|      draft15      |  2019-12-10 | Correct, simplify and futureproof
                                    requirementss for DFDs for
                                    supercompressed images. Clarify that
                                    app's only need to use DFD sample
                                    info when `vkFormat` is
                                    `VK_FORMAT_UNDEFINED`.
|      draft16      |  2019-12-19 | Require non-BasisU supercompression
                                    scheme DFDs retain more sample info.
                                    Fix check equation for kvdByteLength
                                    and add similar for the image data
                                    size. Change value of `hasAlphaSlices`
                                    flag from 2 to 4, a bug fix.
|      draft17      |  2019-12-30 | Change `isLooped` to `loopCount` in
                                    ktxAnimData value.
|      draft18      |  2020-02-08 | Change mip level padding to match 3D
                                    API requirements enabling mmapping.
|      draft19      |  2020-03-04 | specify cubemap faces.
                                    Remove Zlib & LZMA. Limit use of
                                    VK_FORMAT_UNDEFINED to those in the
                                    spec.
|      {docrev}     |  {revdate}  | Relax requirement for KTXwriter.
                                    Allow use of VK_FORMAT_UNDEFINED for
                                    UASTC.
|===

[discrete]
== Acknowledgements
Thanks to Manmohan Bishnoi for designing the KTX file and application
icons.

Thanks to Alexey Knyazev for enormous help tightening the specification
and removing potential conflicts.

Thanks to David Wilkinson for chairing the initial effort.

[discrete,.legal]
== License

[.legal]
--
This specification is protected by copyright laws and contains material
proprietary to the Khronos Group, Inc. It or any components may not be
reproduced, republished, distributed, transmitted, displayed, broadcast,
or otherwise exploited in any manner without the express prior written
permission of Khronos Group. You may use this specification for implementing
the functionality therein, without altering or removing any trademark,
copyright or other notice from the specification, but the receipt or
possession of this specification does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell
anything that it may describe, in whole or in part.

This version of the KTX Specification is published and copyrighted by
Khronos^®^, but is not a Khronos ratified specification. Accordingly, it
does not fall within the scope of the Khronos IP policy, except to the
extent, if any, that sections of it are normatively referenced in ratified
Khronos specifications. Such references incorporate the referenced sections
into the ratified specifications, and bring those sections into the scope
of the policy for those specifications.

Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions of
this specification in any fashion, provided that NO CHARGE is made for the
specification and the latest available update of the specification for any
version of the API is used whenever possible. Such distributed specification
may be reformatted AS LONG AS the contents of the specification are not
changed in any way. The specification may be incorporated into a product
that is sold as long as such product includes significant independent
work developed by the seller. A link to the current version of this
specification on the Khronos Group website should be included whenever
possible with specification distributions.

Khronos Group makes no, and expressly disclaims any, representations or
warranties, express or implied, regarding this specification, including,
without limitation, any implied warranties of merchantability or fitness
for a particular purpose or non-infringement of any intellectual property.
Khronos Group makes no, and expressly disclaims any, warranties, express
or implied, regarding the correctness, accuracy, completeness, timeliness,
and reliability of the specification. Under no circumstances will the
Khronos Group, or any of its Promoters, Contributors or Members or
their respective partners, officers, directors, employees, agents, or
representatives be liable for any damages, whether direct, indirect,
special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.

The KTX icon is a trademark of and © 2018, the Khronos Group, Inc. and
may not be used without the written permission of the Khronos Group.

Khronos is registered trademark, SYCL, SPIR, WebGL, EGL, COLLADA,
StreamInput, OpenVX, OpenKCam, glTF, OpenKODE, OpenVG, OpenWF,
OpenSL ES, OpenMAX, OpenMAX AL, OpenMAX IL and OpenMAX DL are
trademarks and WebCL is a certification mark of the Khronos Group
Inc. OpenCL is a trademark of Apple Inc. and OpenGL and OpenML are
registered trademarks and the OpenGL ES and OpenGL SC logos are
trademarks of Silicon Graphics International used under license by
Khronos.  All other product names, trademarks, and/or company names
are used solely for identification and belong to their respective
owners.
--

// vim: filetype=asciidoc ai expandtab tw=72 ts=4 sts=2 sw=2

